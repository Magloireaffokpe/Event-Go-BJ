{"file_contents":{"README.md":{"content":"# EventGo BJ - Backend API\n\n## Description\nEventGo BJ est une plateforme backend compl√®te pour la gestion d'√©v√©nements avec syst√®me de billetterie, paiements et tableaux de bord.\n\n## Fonctionnalit√©s\n- üîê Authentification JWT avec r√¥les (participant, organisateur, admin)\n- üéâ Gestion compl√®te des √©v√©nements (CRUD avec filtres)\n- üé´ Syst√®me de billets avec QR codes\n- üí≥ Paiements simul√©s (Mobile Money et Carte bancaire)\n- üìä Tableaux de bord pour organisateurs et admins\n- üë• Gestion des utilisateurs et mod√©ration\n- üìß Notifications simul√©es\n\n## Technologies\n- Django REST Framework\n- PostgreSQL\n- JWT Authentication\n- QR Code generation\n- OpenAPI/Swagger documentation\n\n## Installation\n\n### Pr√©requis\n- Python 3.8+\n- PostgreSQL\n- pip\n\n### √âtapes d'installation\n\n1. **Cloner le projet**\n```bash\ngit clone <repository-url>\ncd eventgo-backend\n","size_bytes":873},"main.py":{"content":"\"\"\"\nMain WSGI application module for gunicorn.\nThis file imports the Django WSGI application to make it compatible\nwith the current workflow configuration.\n\"\"\"\n\nfrom eventgo.wsgi import application\n\n# Make the WSGI application available as 'app' for gunicorn\napp = application","size_bytes":276},"manage.py":{"content":"#!/usr/bin/env python\n\"\"\"Django's command-line utility for administrative tasks.\"\"\"\nimport os\nimport sys\n\n\ndef main():\n    \"\"\"Run administrative tasks.\"\"\"\n    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'eventgo.settings')\n    try:\n        from django.core.management import execute_from_command_line\n    except ImportError as exc:\n        raise ImportError(\n            \"Couldn't import Django. Are you sure it's installed and \"\n            \"available on your PYTHONPATH environment variable? Did you \"\n            \"forget to activate a virtual environment?\"\n        ) from exc\n    execute_from_command_line(sys.argv)\n\n\nif __name__ == '__main__':\n    main()\n","size_bytes":663},"openapi.yaml":{"content":"openapi: 3.0.3\ninfo:\n  title: EventGo BJ API\n  version: 1.0.0\n  description: API compl√®te pour la gestion d'√©v√©nements avec billetterie et paiements\n  contact:\n    name: EventGo BJ Team\n    email: support@eventgo.bj\n\nservers:\n  - url: http://localhost:8000/api\n    description: Development server\n\nsecurity:\n  - bearerAuth: []\n\ncomponents:\n  securitySchemes:\n    bearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT\n\n  schemas:\n    User:\n      type: object\n      properties:\n        id:\n          type: integer\n        email:\n          type: string\n          format: email\n        first_name:\n          type: string\n        last_name:\n          type: string\n        phone:\n          type: string\n        role:\n          type: string\n          enum: [participant, organizer, admin]\n        is_active:\n          type: boolean\n        date_joined:\n          type: string\n          format: date-time\n\n    Event:\n      type: object\n      properties:\n        id:\n          type: integer\n        title:\n          type: string\n        description:\n          type: string\n        start_datetime:\n          type: string\n          format: date-time\n        end_datetime:\n          type: string\n          format: date-time\n        location:\n          type: string\n        category:\n          type: string\n          enum: [music, sports, conference, art, theater, other]\n        max_attendees:\n          type: integer\n        organizer:\n          $ref: '#/components/schemas/User'\n        created_at:\n          type: string\n          format: date-time\n        updated_at:\n          type: string\n          format: date-time\n\n    Ticket:\n      type: object\n      properties:\n        id:\n          type: integer\n        name:\n          type: string\n        price:\n          type: number\n          format: decimal\n        quantity_available:\n          type: integer\n        quantity_sold:\n          type: integer\n        event:\n          type: integer\n        created_at:\n          type: string\n          format: date-time\n\n    Purchase:\n      type: object\n      properties:\n        id:\n          type: integer\n        ticket:\n          $ref: '#/components/schemas/Ticket'\n        user:\n          $ref: '#/components/schemas/User'\n        quantity:\n          type: integer\n        total_amount:\n          type: number\n          format: decimal\n        qr_code:\n          type: string\n        status:\n          type: string\n          enum: [pending, paid, cancelled]\n        created_at:\n          type: string\n          format: date-time\n\n    LoginRequest:\n      type: object\n      required:\n        - email\n        - password\n      properties:\n        email:\n          type: string\n          format: email\n        password:\n          type: string\n\n    RegisterRequest:\n      type: object\n      required:\n        - email\n        - password\n        - first_name\n        - last_name\n        - phone\n      properties:\n        email:\n          type: string\n          format: email\n        password:\n          type: string\n        first_name:\n          type: string\n        last_name:\n          type: string\n        phone:\n          type: string\n        role:\n          type: string\n          enum: [participant, organizer]\n          default: participant\n\n    TokenResponse:\n      type: object\n      properties:\n        access:\n          type: string\n        refresh:\n          type: string\n        user:\n          $ref: '#/components/schemas/User'\n\n    PaymentRequest:\n      type: object\n      required:\n        - amount\n        - method\n      properties:\n        amount:\n          type: number\n          format: decimal\n        method:\n          type: string\n          enum: [mobile_money, card]\n        phone:\n          type: string\n          description: Required for mobile money\n        card_number:\n          type: string\n          description: Required for card payment\n        card_expiry:\n          type: string\n          description: Required for card payment\n        card_cvv:\n          type: string\n          description: Required for card payment\n\npaths:\n  /auth/register/:\n    post:\n      tags:\n        - Authentication\n      summary: Inscription utilisateur\n      security: []\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/RegisterRequest'\n      responses:\n        '201':\n          description: Utilisateur cr√©√© avec succ√®s\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/TokenResponse'\n        '400':\n          description: Donn√©es invalides\n\n  /auth/login/:\n    post:\n      tags:\n        - Authentication\n      summary: Connexion utilisateur\n      security: []\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              $ref: '#/components/schemas/LoginRequest'\n      responses:\n        '200':\n          description: Connexion r√©ussie\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/TokenResponse'\n        '401':\n          description: Identifiants invalides\n\n  /auth/refresh/:\n    post:\n      tags:\n        - Authentication\n      summary: Actualiser le token\n      security: []\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                refresh:\n                  type: string\n      responses:\n        '200':\n          description: Token actualis√©\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  access:\n                    type: string\n\n  /users/me/:\n    get:\n      tags:\n        - Users\n      summary: Obtenir le profil utilisateur\n      responses:\n        '200':\n          description: Profil utilisateur\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\n\n    patch:\n      tags:\n        - Users\n      summary: Mettre √† jour le profil\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                first_name:\n                  type: string\n                last_name:\n                  type: string\n                phone:\n                  type: string\n      responses:\n        '200':\n          description: Profil mis √† jour\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\n\n  /events/:\n    get:\n      tags:\n        - Events\n      summary: Liste des √©v√©nements\n      security: []\n      parameters:\n        - name: search\n          in: query\n          schema:\n            type: string\n        - name: category\n          in: query\n          schema:\n            type: string\n        - name: location\n          in: query\n          schema:\n            type: string\n        - name: start_date\n          in: query\n          schema:\n            type: string\n            format: date\n      responses:\n        '200':\n          description: Liste des √©v√©nements\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  results:\n                    type: array\n                    items:\n                      $ref: '#/components/schemas/Event'\n\n    post:\n      tags:\n        - Events\n      summary: Cr√©er un √©v√©nement\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required:\n                - title\n                - start_datetime\n                - end_datetime\n                - location\n              properties:\n                title:\n                  type: string\n                description:\n                  type: string\n                start_datetime:\n                  type: string\n                  format: date-time\n                end_datetime:\n                  type: string\n                  format: date-time\n                location:\n                  type: string\n                category:\n                  type: string\n                max_attendees:\n                  type: integer\n      responses:\n        '201':\n          description: √âv√©nement cr√©√©\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Event'\n\n  /events/{id}/:\n    get:\n      tags:\n        - Events\n      summary: D√©tail d'un √©v√©nement\n      security: []\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: D√©tail de l'√©v√©nement\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Event'\n\n    patch:\n      tags:\n        - Events\n      summary: Modifier un √©v√©nement\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                title:\n                  type: string\n                description:\n                  type: string\n                start_datetime:\n                  type: string\n                  format: date-time\n                end_datetime:\n                  type: string\n                  format: date-time\n                location:\n                  type: string\n                category:\n                  type: string\n                max_attendees:\n                  type: integer\n      responses:\n        '200':\n          description: √âv√©nement modifi√©\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Event'\n\n    delete:\n      tags:\n        - Events\n      summary: Supprimer un √©v√©nement\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '204':\n          description: √âv√©nement supprim√©\n\n  /events/{id}/tickets/:\n    get:\n      tags:\n        - Tickets\n      summary: Liste des billets pour un √©v√©nement\n      security: []\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: Liste des billets\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  $ref: '#/components/schemas/Ticket'\n\n    post:\n      tags:\n        - Tickets\n      summary: Cr√©er un type de billet\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required:\n                - name\n                - price\n                - quantity_available\n              properties:\n                name:\n                  type: string\n                price:\n                  type: number\n                  format: decimal\n                quantity_available:\n                  type: integer\n      responses:\n        '201':\n          description: Billet cr√©√©\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Ticket'\n\n  /tickets/{id}/purchase/:\n    post:\n      tags:\n        - Tickets\n      summary: Acheter un billet\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              required:\n                - quantity\n                - payment_method\n              properties:\n                quantity:\n                  type: integer\n                payment_method:\n                  type: string\n                  enum: [mobile_money, card]\n                phone:\n                  type: string\n                card_number:\n                  type: string\n                card_expiry:\n                  type: string\n                card_cvv:\n                  type: string\n      responses:\n        '201':\n          description: Achat r√©ussi\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Purchase'\n\n  /tickets/{id}/:\n    get:\n      tags:\n        - Tickets\n      summary: D√©tail d'un billet achet√©\n      parameters:\n        - name: id\n          in: path\n          required: true\n          schema:\n            type: integer\n      responses:\n        '200':\n          description: D√©tail du billet avec QR code\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/Purchase'\n\n  /dashboard/organizer/:\n    get:\n      tags:\n        - Dashboard\n      summary: Statistiques organisateur\n      responses:\n        '200':\n          description: Statistiques organisateur\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  total_events:\n                    type: integer\n                  total_sales:\n                    type: number\n                    format: decimal\n                  total_attendees:\n                    type: integer\n                  events:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        event:\n                          $ref: '#/components/schemas/Event'\n                        sales:\n                          type: number\n                          format: decimal\n                        attendees:\n                          type: integer\n\n  /dashboard/admin/:\n    get:\n      tags:\n        - Dashboard\n      summary: Statistiques admin\n      responses:\n        '200':\n          description: Statistiques globales\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  total_users:\n                    type: integer\n                  total_events:\n                    type: integer\n                  total_sales:\n                    type: number\n                    format: decimal\n                  total_revenue:\n                    type: number\n                    format: decimal\n                  monthly_stats:\n                    type: array\n                    items:\n                      type: object\n                      properties:\n                        month:\n                          type: string\n                        events:\n                          type: integer\n                        sales:\n                          type: number\n                          format: decimal\n","size_bytes":15235},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"django>=5.0.0\",\n    \"djangorestframework>=3.15.0\",\n    \"djangorestframework-simplejwt>=5.3.0\",\n    \"django-cors-headers>=4.3.0\",\n    \"django-filter>=24.0\",\n    \"drf-spectacular>=0.27.0\",\n    \"python-decouple>=3.8\",\n    \"qrcode[pil]>=7.4.0\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"dj-database-url>=3.0.1\",\n    \"drf-nested-routers>=0.94.2\",\n]\n","size_bytes":509},"replit.md":{"content":"# EventGo BJ - Backend API\n\n## Overview\n\nEventGo BJ is a comprehensive backend platform for event management with integrated ticketing, payment processing, and dashboard analytics. The system serves three types of users: participants who attend events, organizers who create and manage events, and administrators who oversee the entire platform. The platform provides complete CRUD operations for events, a sophisticated ticketing system with QR code generation, simulated payment processing for Mobile Money and card payments, and comprehensive dashboards for tracking event performance and revenue.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Framework and Structure\n- **Django REST Framework**: Core backend framework providing RESTful API endpoints\n- **Modular App Architecture**: Organized into separate Django apps (users, events, tickets, payments, notifications, dashboards) for clear separation of concerns\n- **PostgreSQL Database**: Primary data storage with proper indexing and relationships\n- **JWT Authentication**: Token-based authentication using djangorestframework-simplejwt for secure API access\n\n### Authentication and Authorization\n- **Custom User Model**: Extended AbstractUser with role-based permissions (participant, organizer, admin)\n- **Role-Based Access Control**: Custom permission classes controlling access to resources based on user roles\n- **JWT Token Management**: Refresh and access token system for secure session management\n\n### Data Architecture\n- **Event Management**: Central Event model with support for categories, locations, and capacity management\n- **Ticketing System**: Separate Ticket and Purchase models with QR code generation using qrcode library\n- **Payment Processing**: Mock payment system supporting Mobile Money and card payments with comprehensive tracking\n- **Notification System**: Template-based notification system with support for email, SMS, and push notifications\n\n### API Design\n- **RESTful Endpoints**: Consistent REST API design with proper HTTP methods and status codes\n- **Nested Resources**: Event-specific tickets and reviews using nested routing\n- **Filtering and Search**: Django-filter integration for complex querying capabilities\n- **API Documentation**: OpenAPI/Swagger documentation using drf-spectacular\n\n### Business Logic\n- **Event Lifecycle Management**: Complete event creation, update, and management workflow\n- **Ticket Sales**: Inventory management, sales tracking, and QR code generation for tickets\n- **Payment Simulation**: Mock payment processing with status tracking and refund capabilities\n- **Dashboard Analytics**: Real-time statistics and reporting for organizers and administrators\n\n### Security and Validation\n- **Input Validation**: Comprehensive serializer validation for all user inputs\n- **Permission System**: Multi-level permission checking at both view and object levels\n- **Data Integrity**: Database constraints and model validation to ensure data consistency\n\n## External Dependencies\n\n### Core Framework Dependencies\n- **Django REST Framework**: Primary API framework for building RESTful endpoints\n- **djangorestframework-simplejwt**: JWT authentication implementation\n- **django-filter**: Advanced filtering capabilities for API endpoints\n- **drf-spectacular**: OpenAPI documentation generation\n\n### Utility Libraries\n- **qrcode**: QR code generation for ticket validation\n- **python-decouple**: Environment variable management for configuration\n- **django-cors-headers**: Cross-origin resource sharing configuration\n\n### Database\n- **PostgreSQL**: Primary database system for data persistence and complex queries\n- **Django ORM**: Database abstraction layer with migration support\n\n### Development and Documentation\n- **django-rest-framework-nested**: Nested routing for related resources\n- **OpenAPI/Swagger**: Automated API documentation and testing interface\n\n### Future Integration Points\n- **Email Services**: Ready for integration with email providers for notifications\n- **SMS Services**: Prepared for SMS notification integration\n- **Payment Gateways**: Architecture supports integration with real payment processors\n- **File Storage**: Configured for media file handling and cloud storage integration","size_bytes":4283},"apps/__init__.py":{"content":"","size_bytes":0},"eventgo/__init__.py":{"content":"","size_bytes":0},"eventgo/asgi.py":{"content":"\"\"\"\nASGI config for eventgo project.\n\nIt exposes the ASGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.2/howto/deployment/asgi/\n\"\"\"\n\nimport os\n\nfrom django.core.asgi import get_asgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'eventgo.settings')\n\napplication = get_asgi_application()\n","size_bytes":391},"eventgo/settings.py":{"content":"\"\"\"\nDjango settings for eventgo project.\n\"\"\"\n\nfrom pathlib import Path\nimport os\nfrom decouple import config\nfrom datetime import timedelta\nimport dj_database_url\n\n# Build paths inside the project like this: BASE_DIR / 'subdir'.\nBASE_DIR = Path(__file__).resolve().parent.parent\n\n# Quick-start development settings - unsuitable for production\n# SECURITY WARNING: keep the secret key used in production secret!\nSECRET_KEY = config('SECRET_KEY', default='django-insecure-change-me-in-production')\n\n# SECURITY WARNING: don't run with debug turned on in production!\nDEBUG = config('DEBUG', default=True, cast=bool)\n\nALLOWED_HOSTS = config('ALLOWED_HOSTS', default='localhost,127.0.0.1,0.0.0.0').split(',')\n\n# Application definition\nDJANGO_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    'django.contrib.contenttypes',\n    'django.contrib.sessions',\n    'django.contrib.messages',\n    'django.contrib.staticfiles',\n]\n\nTHIRD_PARTY_APPS = [\n    'rest_framework',\n    'rest_framework_simplejwt',\n    'corsheaders',\n    'django_filters',\n    'drf_spectacular',\n]\n\nLOCAL_APPS = [\n    'apps.users',\n    'apps.events',\n    'apps.tickets',\n    'apps.payments',\n    'apps.notifications',\n]\n\nINSTALLED_APPS = DJANGO_APPS + THIRD_PARTY_APPS + LOCAL_APPS\n\nMIDDLEWARE = [\n    'corsheaders.middleware.CorsMiddleware',\n    'django.middleware.security.SecurityMiddleware',\n    'django.contrib.sessions.middleware.SessionMiddleware',\n    'django.middleware.common.CommonMiddleware',\n    'django.middleware.csrf.CsrfViewMiddleware',\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\n    'django.contrib.messages.middleware.MessageMiddleware',\n    'django.middleware.clickjacking.XFrameOptionsMiddleware',\n]\n\nROOT_URLCONF = 'eventgo.urls'\n\nTEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': [],\n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n\nWSGI_APPLICATION = 'eventgo.wsgi.application'\n\n# Database\n# Use DATABASE_URL if available, otherwise fall back to individual config\nDATABASE_URL = config('DATABASE_URL', default='')\n\nif DATABASE_URL:\n    DATABASES = {\n        'default': dj_database_url.parse(DATABASE_URL)\n    }\nelse:\n    DATABASES = {\n        'default': {\n            'ENGINE': 'django.db.backends.postgresql',\n            'NAME': config('DATABASE_NAME', default='eventgo_db'),\n            'USER': config('DATABASE_USER', default='postgres'),\n            'PASSWORD': config('DATABASE_PASSWORD', default='password'),\n            'HOST': config('DATABASE_HOST', default='localhost'),\n            'PORT': config('DATABASE_PORT', default='5432'),\n        }\n    }\n\n# Password validation\nAUTH_PASSWORD_VALIDATORS = [\n    {\n        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',\n    },\n    {\n        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',\n    },\n]\n\n# Custom User Model\nAUTH_USER_MODEL = 'users.User'\n\n# Internationalization\nLANGUAGE_CODE = 'en-us'\nTIME_ZONE = 'UTC'\nUSE_I18N = True\nUSE_TZ = True\n\n# Static files (CSS, JavaScript, Images)\nSTATIC_URL = '/static/'\nSTATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')\n\n# Media files\nMEDIA_URL = '/media/'\nMEDIA_ROOT = os.path.join(BASE_DIR, 'media')\n\n# Default primary key field type\nDEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'\n\n# Django REST Framework settings\nREST_FRAMEWORK = {\n    'DEFAULT_AUTHENTICATION_CLASSES': [\n        'rest_framework_simplejwt.authentication.JWTAuthentication',\n    ],\n    'DEFAULT_PERMISSION_CLASSES': [\n        'rest_framework.permissions.IsAuthenticated',\n    ],\n    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',\n    'PAGE_SIZE': 20,\n    'DEFAULT_FILTER_BACKENDS': [\n        'django_filters.rest_framework.DjangoFilterBackend',\n        'rest_framework.filters.SearchFilter',\n        'rest_framework.filters.OrderingFilter',\n    ],\n    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',\n}\n\n# JWT settings\nSIMPLE_JWT = {\n    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=config('JWT_ACCESS_TOKEN_LIFETIME', default=60, cast=int)),\n    'REFRESH_TOKEN_LIFETIME': timedelta(days=config('JWT_REFRESH_TOKEN_LIFETIME', default=1, cast=int)),\n    'ROTATE_REFRESH_TOKENS': True,\n    'BLACKLIST_AFTER_ROTATION': True,\n    'UPDATE_LAST_LOGIN': True,\n    'ALGORITHM': config('JWT_ALGORITHM', default='HS256'),\n    'SIGNING_KEY': config('JWT_SECRET_KEY', default=SECRET_KEY),\n    'VERIFYING_KEY': None,\n    'AUDIENCE': None,\n    'ISSUER': None,\n    'JWK_URL': None,\n    'LEEWAY': 0,\n    'AUTH_HEADER_TYPES': ('Bearer',),\n    'AUTH_HEADER_NAME': 'HTTP_AUTHORIZATION',\n    'USER_ID_FIELD': 'id',\n    'USER_ID_CLAIM': 'user_id',\n    'USER_AUTHENTICATION_RULE': 'rest_framework_simplejwt.authentication.default_user_authentication_rule',\n    'AUTH_TOKEN_CLASSES': ('rest_framework_simplejwt.tokens.AccessToken',),\n    'TOKEN_TYPE_CLAIM': 'token_type',\n    'TOKEN_USER_CLASS': 'rest_framework_simplejwt.models.TokenUser',\n    'JTI_CLAIM': 'jti',\n    'SLIDING_TOKEN_REFRESH_EXP_CLAIM': 'refresh_exp',\n    'SLIDING_TOKEN_LIFETIME': timedelta(minutes=5),\n    'SLIDING_TOKEN_REFRESH_LIFETIME': timedelta(days=1),\n}\n\n# CORS settings\nCORS_ALLOW_ALL_ORIGINS = DEBUG\nCORS_ALLOWED_ORIGINS = [\n    \"http://localhost:3000\",\n    \"http://127.0.0.1:3000\",\n    \"http://localhost:5000\",\n    \"http://127.0.0.1:5000\",\n]\n\nCORS_ALLOW_CREDENTIALS = True\n\n# CSRF settings for API\nCSRF_COOKIE_SECURE = not DEBUG\nCSRF_COOKIE_HTTPONLY = True\nCSRF_TRUSTED_ORIGINS = [\n    \"http://localhost:3000\",\n    \"http://127.0.0.1:3000\",\n    \"http://localhost:5000\",\n    \"http://127.0.0.1:5000\",\n]\n\n# Email configuration\nEMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend' if DEBUG else 'django.core.mail.backends.smtp.EmailBackend'\nEMAIL_HOST = config('EMAIL_HOST', default='smtp.gmail.com')\nEMAIL_PORT = config('EMAIL_PORT', default=587, cast=int)\nEMAIL_USE_TLS = config('EMAIL_USE_TLS', default=True, cast=bool)\nEMAIL_HOST_USER = config('EMAIL_HOST_USER', default='')\nEMAIL_HOST_PASSWORD = config('EMAIL_HOST_PASSWORD', default='')\n\n# Mobile Money and Card Payment settings (Mock)\nMOBILE_MONEY_API_KEY = config('MOBILE_MONEY_API_KEY', default='mock-api-key')\nMOBILE_MONEY_API_URL = config('MOBILE_MONEY_API_URL', default='https://api.mobilemoney.mock')\nCARD_PAYMENT_API_KEY = config('CARD_PAYMENT_API_KEY', default='mock-card-api-key')\nCARD_PAYMENT_API_URL = config('CARD_PAYMENT_API_URL', default='https://api.cardpayment.mock')\n\n# DRF Spectacular settings\nSPECTACULAR_SETTINGS = {\n    'TITLE': 'EventGo BJ API',\n    'DESCRIPTION': 'API compl√®te pour la gestion d\\'√©v√©nements avec billetterie',\n    'VERSION': '1.0.0',\n    'SERVE_INCLUDE_SCHEMA': False,\n    'COMPONENT_SPLIT_REQUEST': True,\n}\n\n# Security settings\nSECURE_BROWSER_XSS_FILTER = True\nSECURE_CONTENT_TYPE_NOSNIFF = True\nX_FRAME_OPTIONS = 'DENY'\n\n# Logging configuration\nLOGGING = {\n    'version': 1,\n    'disable_existing_loggers': False,\n    'handlers': {\n        'file': {\n            'level': 'INFO',\n            'class': 'logging.FileHandler',\n            'filename': 'django.log',\n        },\n        'console': {\n            'level': 'INFO',\n            'class': 'logging.StreamHandler',\n        },\n    },\n    'root': {\n        'handlers': ['console', 'file'],\n        'level': 'INFO',\n    },\n}\n","size_bytes":7811},"eventgo/urls.py":{"content":"\"\"\"eventgo URL Configuration\"\"\"\nfrom django.contrib import admin\nfrom django.urls import path, include\nfrom django.conf import settings\nfrom django.conf.urls.static import static\nfrom drf_spectacular.views import SpectacularAPIView, SpectacularRedocView, SpectacularSwaggerView\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    \n    # API URLs\n    path('api/auth/', include('apps.users.urls')),\n    path('api/users/', include('apps.users.urls')),\n    path('api/events/', include('apps.events.urls')),\n    path('api/tickets/', include('apps.tickets.urls')),\n    path('api/payments/', include('apps.payments.urls')),\n    path('api/notifications/', include('apps.notifications.urls')),\n    path('api/dashboard/', include('apps.dashboards.urls')),\n    \n    # API Documentation\n    path('api/schema/', SpectacularAPIView.as_view(), name='schema'),\n    path('api/schema/swagger-ui/', SpectacularSwaggerView.as_view(url_name='schema'), name='swagger-ui'),\n    path('api/schema/redoc/', SpectacularRedocView.as_view(url_name='schema'), name='redoc'),\n]\n\n# Serve media files during development\nif settings.DEBUG:\n    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)\n","size_bytes":1193},"eventgo/wsgi.py":{"content":"\"\"\"\nWSGI config for eventgo project.\n\nIt exposes the WSGI callable as a module-level variable named ``application``.\n\nFor more information on this file, see\nhttps://docs.djangoproject.com/en/4.2/howto/deployment/wsgi/\n\"\"\"\n\nimport os\n\nfrom django.core.wsgi import get_wsgi_application\n\nos.environ.setdefault('DJANGO_SETTINGS_MODULE', 'eventgo.settings')\n\napplication = get_wsgi_application()\n","size_bytes":391},"apps/dashboards/__init__.py":{"content":"","size_bytes":0},"apps/dashboards/serializers.py":{"content":"from rest_framework import serializers\n\nclass EventStatsSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for detailed event statistics\n    \"\"\"\n    event = serializers.DictField()\n    total_revenue = serializers.DecimalField(max_digits=10, decimal_places=2)\n    total_tickets_sold = serializers.IntegerField()\n    total_tickets_available = serializers.IntegerField()\n    attendance_rate = serializers.FloatField()\n    sales_by_ticket = serializers.ListField()\n    daily_sales = serializers.ListField()\n    payment_methods = serializers.DictField()\n\nclass OrganizerDashboardSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for organizer dashboard data\n    \"\"\"\n    total_events = serializers.IntegerField()\n    active_events = serializers.IntegerField()\n    upcoming_events = serializers.IntegerField()\n    past_events = serializers.IntegerField()\n    total_revenue = serializers.DecimalField(max_digits=15, decimal_places=2)\n    total_tickets_sold = serializers.IntegerField()\n    total_attendees = serializers.IntegerField()\n    recent_events = serializers.ListField()\n    monthly_revenue = serializers.ListField()\n    top_events = serializers.ListField()\n\nclass UserStatsSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for user statistics\n    \"\"\"\n    total_users = serializers.IntegerField()\n    new_users_this_month = serializers.IntegerField()\n    users_by_role = serializers.DictField()\n\nclass RevenueStatsSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for revenue statistics\n    \"\"\"\n    total_revenue = serializers.DecimalField(max_digits=15, decimal_places=2)\n    total_tickets_sold = serializers.IntegerField()\n    total_payments = serializers.IntegerField()\n    payment_success_rate = serializers.FloatField()\n    payments_by_method = serializers.DictField()\n\nclass AdminDashboardSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for admin dashboard data\n    \"\"\"\n    user_stats = UserStatsSerializer()\n    event_stats = serializers.DictField()\n    revenue_stats = RevenueStatsSerializer()\n    monthly_stats = serializers.ListField()\n    top_events = serializers.ListField()\n    top_organizers = serializers.ListField()\n    recent_activity = serializers.DictField()\n\nclass MonthlyStatsSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for monthly statistics\n    \"\"\"\n    month = serializers.CharField()\n    users = serializers.IntegerField()\n    events = serializers.IntegerField()\n    revenue = serializers.DecimalField(max_digits=15, decimal_places=2)\n    tickets_sold = serializers.IntegerField()\n","size_bytes":2566},"apps/dashboards/urls.py":{"content":"from django.urls import path\n\nfrom .views import OrganizerDashboardView, AdminDashboardView, EventStatsView\n\nurlpatterns = [\n    path('organizer/', OrganizerDashboardView.as_view(), name='organizer-dashboard'),\n    path('admin/', AdminDashboardView.as_view(), name='admin-dashboard'),\n    path('events/<int:event_id>/stats/', EventStatsView.as_view(), name='event-stats'),\n]\n","size_bytes":375},"apps/dashboards/views.py":{"content":"from rest_framework import generics, permissions, status\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom django.db.models import Sum, Count, Q, Avg\nfrom django.utils import timezone\nfrom drf_spectacular.utils import extend_schema, OpenApiResponse\nfrom datetime import timedelta\nfrom decimal import Decimal\n\nfrom apps.events.models import Event\nfrom apps.tickets.models import Purchase, Ticket\nfrom apps.payments.models import Payment\nfrom apps.users.models import User\nfrom .serializers import (\n    OrganizerDashboardSerializer,\n    AdminDashboardSerializer,\n    EventStatsSerializer,\n    UserStatsSerializer,\n    RevenueStatsSerializer\n)\n\nclass DashboardPermission(permissions.BasePermission):\n    \"\"\"\n    Custom permission for dashboard endpoints\n    \"\"\"\n    def has_permission(self, request, view):\n        return request.user.is_authenticated and request.user.role in ['organizer', 'admin']\n\nclass OrganizerDashboardView(APIView):\n    \"\"\"\n    Dashboard view for event organizers\n    \"\"\"\n    permission_classes = [DashboardPermission]\n    \n    @extend_schema(\n        summary=\"Get Organizer Dashboard\",\n        description=\"Get dashboard data for event organizers\",\n        responses={200: OrganizerDashboardSerializer}\n    )\n    def get(self, request):\n        user = request.user\n        \n        if user.role not in ['organizer', 'admin']:\n            return Response({\n                'error': 'Permission denied'\n            }, status=status.HTTP_403_FORBIDDEN)\n        \n        # Get organizer's events\n        if user.role == 'admin':\n            # Admin can see all events, but for organizer dashboard, show their own\n            events = Event.objects.filter(organizer=user)\n        else:\n            events = Event.objects.filter(organizer=user)\n        \n        # Calculate basic stats\n        total_events = events.count()\n        active_events = events.filter(is_active=True).count()\n        upcoming_events = events.filter(start_datetime__gt=timezone.now()).count()\n        past_events = events.filter(end_datetime__lt=timezone.now()).count()\n        \n        # Calculate sales stats\n        event_ids = events.values_list('id', flat=True)\n        paid_purchases = Purchase.objects.filter(\n            ticket__event_id__in=event_ids,\n            status='paid'\n        )\n        \n        total_sales = paid_purchases.aggregate(\n            total_amount=Sum('total_amount'),\n            total_tickets=Sum('quantity')\n        )\n        \n        total_revenue = total_sales['total_amount'] or Decimal('0.00')\n        total_tickets_sold = total_sales['total_tickets'] or 0\n        \n        # Calculate attendee stats\n        total_attendees = paid_purchases.aggregate(\n            total=Sum('quantity')\n        )['total'] or 0\n        \n        # Get recent events with stats\n        recent_events = []\n        for event in events.order_by('-created_at')[:5]:\n            event_purchases = Purchase.objects.filter(\n                ticket__event=event,\n                status='paid'\n            )\n            \n            event_revenue = event_purchases.aggregate(\n                total=Sum('total_amount')\n            )['total'] or Decimal('0.00')\n            \n            event_attendees = event_purchases.aggregate(\n                total=Sum('quantity')\n            )['total'] or 0\n            \n            recent_events.append({\n                'id': event.id,\n                'title': event.title,\n                'start_datetime': event.start_datetime,\n                'location': event.location,\n                'revenue': float(event_revenue),\n                'attendees': event_attendees,\n                'max_attendees': event.max_attendees,\n                'status': 'upcoming' if event.is_upcoming else 'ongoing' if event.is_ongoing else 'past'\n            })\n        \n        # Calculate monthly revenue for the last 6 months\n        monthly_revenue = []\n        for i in range(6):\n            month_start = timezone.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0) - timedelta(days=30*i)\n            month_end = month_start.replace(day=28) + timedelta(days=4)\n            month_end = month_end - timedelta(days=month_end.day)\n            \n            month_purchases = paid_purchases.filter(\n                created_at__range=[month_start, month_end]\n            )\n            \n            revenue = month_purchases.aggregate(Sum('total_amount'))['total_amount'] or Decimal('0.00')\n            ticket_count = month_purchases.aggregate(Sum('quantity'))['quantity'] or 0\n            \n            monthly_revenue.append({\n                'month': month_start.strftime('%Y-%m'),\n                'revenue': float(revenue),\n                'tickets_sold': ticket_count\n            })\n        \n        monthly_revenue.reverse()  # Show oldest to newest\n        \n        # Top performing events\n        top_events = []\n        for event in events.annotate(\n            revenue=Sum('tickets__purchases__total_amount', filter=Q(tickets__purchases__status='paid'))\n        ).order_by('-revenue')[:5]:\n            top_events.append({\n                'id': event.id,\n                'title': event.title,\n                'revenue': float(event.revenue or 0),\n                'attendees': event.total_tickets_sold\n            })\n        \n        dashboard_data = {\n            'total_events': total_events,\n            'active_events': active_events,\n            'upcoming_events': upcoming_events,\n            'past_events': past_events,\n            'total_revenue': float(total_revenue),\n            'total_tickets_sold': total_tickets_sold,\n            'total_attendees': total_attendees,\n            'recent_events': recent_events,\n            'monthly_revenue': monthly_revenue,\n            'top_events': top_events\n        }\n        \n        serializer = OrganizerDashboardSerializer(dashboard_data)\n        return Response(serializer.data)\n\nclass AdminDashboardView(APIView):\n    \"\"\"\n    Dashboard view for administrators\n    \"\"\"\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_permissions(self):\n        \"\"\"Only admins can access this dashboard\"\"\"\n        if self.request.user.is_authenticated and self.request.user.role == 'admin':\n            return [permissions.IsAuthenticated()]\n        return [permissions.DenyAll()]\n    \n    @extend_schema(\n        summary=\"Get Admin Dashboard\",\n        description=\"Get dashboard data for administrators\",\n        responses={200: AdminDashboardSerializer}\n    )\n    def get(self, request):\n        # User statistics\n        total_users = User.objects.count()\n        new_users_this_month = User.objects.filter(\n            date_joined__gte=timezone.now().replace(day=1)\n        ).count()\n        \n        users_by_role = dict(\n            User.objects.values('role').annotate(count=Count('id')).values_list('role', 'count')\n        )\n        \n        # Event statistics\n        total_events = Event.objects.count()\n        active_events = Event.objects.filter(is_active=True).count()\n        events_this_month = Event.objects.filter(\n            created_at__gte=timezone.now().replace(day=1)\n        ).count()\n        \n        # Sales statistics\n        paid_purchases = Purchase.objects.filter(status='paid')\n        total_sales = paid_purchases.aggregate(\n            total_amount=Sum('total_amount'),\n            total_tickets=Sum('quantity')\n        )\n        \n        total_revenue = total_sales['total_amount'] or Decimal('0.00')\n        total_tickets_sold = total_sales['total_tickets'] or 0\n        \n        # Payment statistics\n        total_payments = Payment.objects.count()\n        successful_payments = Payment.objects.filter(status='success').count()\n        payment_success_rate = (successful_payments / total_payments * 100) if total_payments > 0 else 0\n        \n        payments_by_method = dict(\n            Payment.objects.values('method').annotate(count=Count('id')).values_list('method', 'count')\n        )\n        \n        # Monthly statistics for the last 12 months\n        monthly_stats = []\n        for i in range(12):\n            month_start = timezone.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0) - timedelta(days=30*i)\n            month_end = month_start.replace(day=28) + timedelta(days=4)\n            month_end = month_end - timedelta(days=month_end.day)\n            \n            # Users registered this month\n            month_users = User.objects.filter(\n                date_joined__range=[month_start, month_end]\n            ).count()\n            \n            # Events created this month\n            month_events = Event.objects.filter(\n                created_at__range=[month_start, month_end]\n            ).count()\n            \n            # Revenue this month\n            month_revenue = paid_purchases.filter(\n                created_at__range=[month_start, month_end]\n            ).aggregate(Sum('total_amount'))['total_amount'] or Decimal('0.00')\n            \n            # Tickets sold this month\n            month_tickets = paid_purchases.filter(\n                created_at__range=[month_start, month_end]\n            ).aggregate(Sum('quantity'))['quantity'] or 0\n            \n            monthly_stats.append({\n                'month': month_start.strftime('%Y-%m'),\n                'users': month_users,\n                'events': month_events,\n                'revenue': float(month_revenue),\n                'tickets_sold': month_tickets\n            })\n        \n        monthly_stats.reverse()  # Show oldest to newest\n        \n        # Top events by revenue\n        top_events = Event.objects.annotate(\n            revenue=Sum('tickets__purchases__total_amount', filter=Q(tickets__purchases__status='paid')),\n            tickets_sold=Sum('tickets__purchases__quantity', filter=Q(tickets__purchases__status='paid'))\n        ).order_by('-revenue')[:10]\n        \n        top_events_data = []\n        for event in top_events:\n            if event.revenue:  # Only include events with sales\n                top_events_data.append({\n                    'id': event.id,\n                    'title': event.title,\n                    'organizer': event.organizer.full_name,\n                    'revenue': float(event.revenue),\n                    'tickets_sold': event.tickets_sold or 0,\n                    'start_date': event.start_datetime.date()\n                })\n        \n        # Top organizers by revenue\n        from django.db.models import F\n        top_organizers = User.objects.filter(role='organizer').annotate(\n            revenue=Sum('organized_events__tickets__purchases__total_amount', \n                       filter=Q(organized_events__tickets__purchases__status='paid')),\n            events_count=Count('organized_events', filter=Q(organized_events__is_active=True))\n        ).filter(revenue__isnull=False).order_by('-revenue')[:10]\n        \n        top_organizers_data = []\n        for organizer in top_organizers:\n            top_organizers_data.append({\n                'id': organizer.id,\n                'name': organizer.full_name,\n                'email': organizer.email,\n                'events_count': organizer.events_count,\n                'revenue': float(organizer.revenue)\n            })\n        \n        # Recent activity\n        recent_users = User.objects.order_by('-date_joined')[:5]\n        recent_events = Event.objects.order_by('-created_at')[:5]\n        recent_purchases = Purchase.objects.filter(status='paid').order_by('-created_at')[:5]\n        \n        dashboard_data = {\n            'user_stats': {\n                'total_users': total_users,\n                'new_users_this_month': new_users_this_month,\n                'users_by_role': users_by_role\n            },\n            'event_stats': {\n                'total_events': total_events,\n                'active_events': active_events,\n                'events_this_month': events_this_month\n            },\n            'revenue_stats': {\n                'total_revenue': float(total_revenue),\n                'total_tickets_sold': total_tickets_sold,\n                'total_payments': total_payments,\n                'payment_success_rate': payment_success_rate,\n                'payments_by_method': payments_by_method\n            },\n            'monthly_stats': monthly_stats,\n            'top_events': top_events_data,\n            'top_organizers': top_organizers_data,\n            'recent_activity': {\n                'recent_users': [{'id': u.id, 'name': u.full_name, 'email': u.email, 'date_joined': u.date_joined} for u in recent_users],\n                'recent_events': [{'id': e.id, 'title': e.title, 'organizer': e.organizer.full_name, 'created_at': e.created_at} for e in recent_events],\n                'recent_purchases': [{'id': p.id, 'reference': p.purchase_reference, 'amount': float(p.total_amount), 'user': p.user.full_name, 'created_at': p.created_at} for p in recent_purchases]\n            }\n        }\n        \n        serializer = AdminDashboardSerializer(dashboard_data)\n        return Response(serializer.data)\n\nclass EventStatsView(APIView):\n    \"\"\"\n    Detailed statistics for a specific event\n    \"\"\"\n    permission_classes = [permissions.IsAuthenticated]\n    \n    @extend_schema(\n        summary=\"Get Event Statistics\",\n        description=\"Get detailed statistics for a specific event\",\n        responses={200: EventStatsSerializer}\n    )\n    def get(self, request, event_id):\n        try:\n            event = Event.objects.get(id=event_id)\n        except Event.DoesNotExist:\n            return Response({\n                'error': 'Event not found'\n            }, status=status.HTTP_404_NOT_FOUND)\n        \n        # Check permission\n        if request.user.role not in ['admin'] and event.organizer != request.user:\n            return Response({\n                'error': 'Permission denied'\n            }, status=status.HTTP_403_FORBIDDEN)\n        \n        # Get event tickets and purchases\n        tickets = Ticket.objects.filter(event=event)\n        purchases = Purchase.objects.filter(ticket__event=event, status='paid')\n        \n        # Basic stats\n        total_revenue = purchases.aggregate(Sum('total_amount'))['total_amount'] or Decimal('0.00')\n        total_tickets_sold = purchases.aggregate(Sum('quantity'))['quantity'] or 0\n        total_tickets_available = tickets.aggregate(Sum('quantity_available'))['quantity_available'] or 0\n        \n        # Sales by ticket type\n        sales_by_ticket = []\n        for ticket in tickets:\n            ticket_purchases = purchases.filter(ticket=ticket)\n            ticket_revenue = ticket_purchases.aggregate(Sum('total_amount'))['total_amount'] or Decimal('0.00')\n            ticket_sold = ticket_purchases.aggregate(Sum('quantity'))['quantity'] or 0\n            \n            sales_by_ticket.append({\n                'ticket_name': ticket.name,\n                'price': float(ticket.price),\n                'available': ticket.quantity_available,\n                'sold': ticket_sold,\n                'revenue': float(ticket_revenue),\n                'sold_percentage': (ticket_sold / ticket.quantity_available * 100) if ticket.quantity_available > 0 else 0\n            })\n        \n        # Daily sales (last 30 days)\n        daily_sales = []\n        for i in range(30):\n            day = timezone.now().date() - timedelta(days=i)\n            day_start = timezone.datetime.combine(day, timezone.datetime.min.time())\n            day_end = timezone.datetime.combine(day, timezone.datetime.max.time())\n            \n            day_purchases = purchases.filter(created_at__range=[day_start, day_end])\n            day_revenue = day_purchases.aggregate(Sum('total_amount'))['total_amount'] or Decimal('0.00')\n            day_tickets = day_purchases.aggregate(Sum('quantity'))['quantity'] or 0\n            \n            daily_sales.append({\n                'date': day.isoformat(),\n                'revenue': float(day_revenue),\n                'tickets_sold': day_tickets\n            })\n        \n        daily_sales.reverse()  # Show oldest to newest\n        \n        # Payment methods\n        payment_methods = dict(\n            purchases.values('payment_method').annotate(count=Count('id')).values_list('payment_method', 'count')\n        )\n        \n        stats_data = {\n            'event': {\n                'id': event.id,\n                'title': event.title,\n                'start_datetime': event.start_datetime,\n                'max_attendees': event.max_attendees\n            },\n            'total_revenue': float(total_revenue),\n            'total_tickets_sold': total_tickets_sold,\n            'total_tickets_available': total_tickets_available,\n            'attendance_rate': (total_tickets_sold / event.max_attendees * 100) if event.max_attendees > 0 else 0,\n            'sales_by_ticket': sales_by_ticket,\n            'daily_sales': daily_sales,\n            'payment_methods': payment_methods\n        }\n        \n        serializer = EventStatsSerializer(stats_data)\n        return Response(serializer.data)\n","size_bytes":17003},"apps/events/__init__.py":{"content":"","size_bytes":0},"apps/events/models.py":{"content":"from django.db import models\nfrom django.contrib.auth import get_user_model\nfrom django.core.validators import MinValueValidator\nfrom django.utils import timezone\n\nUser = get_user_model()\n\nclass Event(models.Model):\n    \"\"\"\n    Event model for managing events\n    \"\"\"\n    CATEGORY_CHOICES = [\n        ('music', 'Music'),\n        ('sports', 'Sports'),\n        ('conference', 'Conference'),\n        ('art', 'Art'),\n        ('theater', 'Theater'),\n        ('other', 'Other'),\n    ]\n    \n    title = models.CharField(max_length=200)\n    description = models.TextField(blank=True)\n    start_datetime = models.DateTimeField()\n    end_datetime = models.DateTimeField()\n    location = models.CharField(max_length=200)\n    category = models.CharField(max_length=20, choices=CATEGORY_CHOICES, default='other')\n    max_attendees = models.PositiveIntegerField(validators=[MinValueValidator(1)])\n    \n    # Event management\n    organizer = models.ForeignKey(User, on_delete=models.CASCADE, related_name='organized_events')\n    is_active = models.BooleanField(default=True)\n    is_featured = models.BooleanField(default=False)\n    \n    # Timestamps\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        db_table = 'events'\n        verbose_name = 'Event'\n        verbose_name_plural = 'Events'\n        ordering = ['-created_at']\n        indexes = [\n            models.Index(fields=['start_datetime']),\n            models.Index(fields=['category']),\n            models.Index(fields=['location']),\n            models.Index(fields=['is_active']),\n        ]\n    \n    def __str__(self):\n        return f\"{self.title} - {self.start_datetime.strftime('%Y-%m-%d %H:%M')}\"\n    \n    def clean(self):\n        \"\"\"Validate that end_datetime is after start_datetime\"\"\"\n        if self.start_datetime and self.end_datetime:\n            if self.end_datetime <= self.start_datetime:\n                from django.core.exceptions import ValidationError\n                raise ValidationError(\"End datetime must be after start datetime\")\n    \n    @property\n    def is_upcoming(self):\n        \"\"\"Check if the event is upcoming\"\"\"\n        return self.start_datetime > timezone.now()\n    \n    @property\n    def is_ongoing(self):\n        \"\"\"Check if the event is currently ongoing\"\"\"\n        now = timezone.now()\n        return self.start_datetime <= now <= self.end_datetime\n    \n    @property\n    def is_past(self):\n        \"\"\"Check if the event has ended\"\"\"\n        return self.end_datetime < timezone.now()\n    \n    @property\n    def total_tickets_sold(self):\n        \"\"\"Get total number of tickets sold for this event\"\"\"\n        from apps.tickets.models import Purchase\n        return Purchase.objects.filter(\n            ticket__event=self,\n            status='paid'\n        ).aggregate(\n            total=models.Sum('quantity')\n        )['total'] or 0\n    \n    @property\n    def total_revenue(self):\n        \"\"\"Get total revenue from ticket sales\"\"\"\n        from apps.tickets.models import Purchase\n        return Purchase.objects.filter(\n            ticket__event=self,\n            status='paid'\n        ).aggregate(\n            total=models.Sum('total_amount')\n        )['total'] or 0\n    \n    @property\n    def tickets_available(self):\n        \"\"\"Check if there are still tickets available\"\"\"\n        return self.total_tickets_sold < self.max_attendees\n    \n    @property\n    def available_spots(self):\n        \"\"\"Get number of available spots\"\"\"\n        return max(0, self.max_attendees - self.total_tickets_sold)\n\nclass EventImage(models.Model):\n    \"\"\"\n    Model for storing event images\n    \"\"\"\n    event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='images')\n    image = models.ImageField(upload_to='events/images/')\n    caption = models.CharField(max_length=200, blank=True)\n    is_primary = models.BooleanField(default=False)\n    created_at = models.DateTimeField(auto_now_add=True)\n    \n    class Meta:\n        db_table = 'event_images'\n        verbose_name = 'Event Image'\n        verbose_name_plural = 'Event Images'\n    \n    def __str__(self):\n        return f\"Image for {self.event.title}\"\n    \n    def save(self, *args, **kwargs):\n        \"\"\"Ensure only one primary image per event\"\"\"\n        if self.is_primary:\n            EventImage.objects.filter(\n                event=self.event, \n                is_primary=True\n            ).update(is_primary=False)\n        super().save(*args, **kwargs)\n\nclass EventReview(models.Model):\n    \"\"\"\n    Model for event reviews\n    \"\"\"\n    event = models.ForeignKey(Event, on_delete=models.CASCADE, related_name='reviews')\n    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='event_reviews')\n    rating = models.PositiveIntegerField(\n        validators=[MinValueValidator(1)],\n        help_text=\"Rating from 1 to 5\"\n    )\n    comment = models.TextField(blank=True)\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        db_table = 'event_reviews'\n        verbose_name = 'Event Review'\n        verbose_name_plural = 'Event Reviews'\n        unique_together = ['event', 'user']  # One review per user per event\n        ordering = ['-created_at']\n    \n    def __str__(self):\n        return f\"Review by {self.user.full_name} for {self.event.title}\"\n    \n    def clean(self):\n        \"\"\"Validate rating is between 1 and 5\"\"\"\n        if self.rating < 1 or self.rating > 5:\n            from django.core.exceptions import ValidationError\n            raise ValidationError(\"Rating must be between 1 and 5\")\n","size_bytes":5629},"apps/events/serializers.py":{"content":"from rest_framework import serializers\nfrom django.utils import timezone\nfrom .models import Event, EventImage, EventReview\nfrom apps.users.serializers import UserSerializer\n\nclass EventImageSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Event Images\n    \"\"\"\n    class Meta:\n        model = EventImage\n        fields = ['id', 'image', 'caption', 'is_primary', 'created_at']\n        read_only_fields = ['id', 'created_at']\n\nclass EventReviewSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Event Reviews\n    \"\"\"\n    user = UserSerializer(read_only=True)\n    \n    class Meta:\n        model = EventReview\n        fields = ['id', 'user', 'rating', 'comment', 'created_at', 'updated_at']\n        read_only_fields = ['id', 'user', 'created_at', 'updated_at']\n    \n    def validate_rating(self, value):\n        if value < 1 or value > 5:\n            raise serializers.ValidationError(\"Rating must be between 1 and 5\")\n        return value\n\nclass EventSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Event model\n    \"\"\"\n    organizer = UserSerializer(read_only=True)\n    images = EventImageSerializer(many=True, read_only=True)\n    reviews = EventReviewSerializer(many=True, read_only=True)\n    total_tickets_sold = serializers.ReadOnlyField()\n    total_revenue = serializers.ReadOnlyField()\n    tickets_available = serializers.ReadOnlyField()\n    available_spots = serializers.ReadOnlyField()\n    is_upcoming = serializers.ReadOnlyField()\n    is_ongoing = serializers.ReadOnlyField()\n    is_past = serializers.ReadOnlyField()\n    \n    class Meta:\n        model = Event\n        fields = [\n            'id', 'title', 'description', 'start_datetime', 'end_datetime',\n            'location', 'category', 'max_attendees', 'organizer', 'is_active',\n            'is_featured', 'created_at', 'updated_at', 'images', 'reviews',\n            'total_tickets_sold', 'total_revenue', 'tickets_available',\n            'available_spots', 'is_upcoming', 'is_ongoing', 'is_past'\n        ]\n        read_only_fields = [\n            'id', 'organizer', 'created_at', 'updated_at', 'total_tickets_sold',\n            'total_revenue', 'tickets_available', 'available_spots',\n            'is_upcoming', 'is_ongoing', 'is_past'\n        ]\n    \n    def validate(self, attrs):\n        \"\"\"Validate event dates\"\"\"\n        start_datetime = attrs.get('start_datetime')\n        end_datetime = attrs.get('end_datetime')\n        \n        if start_datetime and end_datetime:\n            if end_datetime <= start_datetime:\n                raise serializers.ValidationError(\n                    \"End datetime must be after start datetime\"\n                )\n            \n            # Check if start datetime is in the future (for new events)\n            if not self.instance and start_datetime <= timezone.now():\n                raise serializers.ValidationError(\n                    \"Start datetime must be in the future\"\n                )\n        \n        return attrs\n    \n    def validate_max_attendees(self, value):\n        if value < 1:\n            raise serializers.ValidationError(\"Max attendees must be at least 1\")\n        return value\n    \n    def create(self, validated_data):\n        # Set the organizer to the current user\n        validated_data['organizer'] = self.context['request'].user\n        return super().create(validated_data)\n\nclass EventListSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Lightweight serializer for event listing\n    \"\"\"\n    organizer_name = serializers.CharField(source='organizer.full_name', read_only=True)\n    total_tickets_sold = serializers.ReadOnlyField()\n    available_spots = serializers.ReadOnlyField()\n    is_upcoming = serializers.ReadOnlyField()\n    primary_image = serializers.SerializerMethodField()\n    \n    class Meta:\n        model = Event\n        fields = [\n            'id', 'title', 'start_datetime', 'end_datetime', 'location',\n            'category', 'max_attendees', 'organizer_name', 'is_active',\n            'is_featured', 'total_tickets_sold', 'available_spots',\n            'is_upcoming', 'primary_image', 'created_at'\n        ]\n    \n    def get_primary_image(self, obj):\n        \"\"\"Get primary image URL\"\"\"\n        primary_image = obj.images.filter(is_primary=True).first()\n        if primary_image:\n            request = self.context.get('request')\n            if request:\n                return request.build_absolute_uri(primary_image.image.url)\n        return None\n\nclass EventCreateUpdateSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for creating and updating events\n    \"\"\"\n    class Meta:\n        model = Event\n        fields = [\n            'title', 'description', 'start_datetime', 'end_datetime',\n            'location', 'category', 'max_attendees', 'is_featured'\n        ]\n    \n    def validate(self, attrs):\n        \"\"\"Validate event dates\"\"\"\n        start_datetime = attrs.get('start_datetime', self.instance.start_datetime if self.instance else None)\n        end_datetime = attrs.get('end_datetime', self.instance.end_datetime if self.instance else None)\n        \n        if start_datetime and end_datetime:\n            if end_datetime <= start_datetime:\n                raise serializers.ValidationError({\n                    'end_datetime': \"End datetime must be after start datetime\"\n                })\n            \n            # For new events, check if start datetime is in the future\n            if not self.instance and start_datetime <= timezone.now():\n                raise serializers.ValidationError({\n                    'start_datetime': \"Start datetime must be in the future\"\n                })\n        \n        return attrs\n    \n    def validate_max_attendees(self, value):\n        \"\"\"Validate max attendees\"\"\"\n        if value < 1:\n            raise serializers.ValidationError(\"Max attendees must be at least 1\")\n        \n        # If updating an existing event, ensure new max_attendees >= tickets_sold\n        if self.instance:\n            if value < self.instance.total_tickets_sold:\n                raise serializers.ValidationError(\n                    f\"Cannot reduce max attendees below current ticket sales ({self.instance.total_tickets_sold})\"\n                )\n        \n        return value\n    \n    def create(self, validated_data):\n        validated_data['organizer'] = self.context['request'].user\n        return super().create(validated_data)\n","size_bytes":6395},"apps/events/tests.py":{"content":"from django.test import TestCase\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom rest_framework.test import APITestCase\nfrom rest_framework import status\nfrom django.contrib.auth import get_user_model\nfrom datetime import timedelta\n\nfrom .models import Event, EventReview\n\nUser = get_user_model()\n\nclass EventModelTest(TestCase):\n    \"\"\"\n    Test cases for Event model\n    \"\"\"\n    \n    def setUp(self):\n        self.organizer = User.objects.create_user(\n            email='organizer@example.com',\n            password='testpass123',\n            first_name='Jane',\n            last_name='Organizer',\n            role='organizer'\n        )\n        \n        self.event_data = {\n            'title': 'Test Event',\n            'description': 'Test event description',\n            'start_datetime': timezone.now() + timedelta(days=7),\n            'end_datetime': timezone.now() + timedelta(days=7, hours=3),\n            'location': 'Cotonou',\n            'category': 'music',\n            'max_attendees': 100,\n            'organizer': self.organizer\n        }\n    \n    def test_create_event(self):\n        \"\"\"Test creating an event\"\"\"\n        event = Event.objects.create(**self.event_data)\n        \n        self.assertEqual(event.title, self.event_data['title'])\n        self.assertEqual(event.organizer, self.organizer)\n        self.assertTrue(event.is_active)\n        self.assertTrue(event.is_upcoming)\n        self.assertFalse(event.is_ongoing)\n        self.assertFalse(event.is_past)\n    \n    def test_event_string_representation(self):\n        \"\"\"Test event string representation\"\"\"\n        event = Event.objects.create(**self.event_data)\n        expected_str = f\"{event.title} - {event.start_datetime.strftime('%Y-%m-%d %H:%M')}\"\n        self.assertEqual(str(event), expected_str)\n    \n    def test_event_status_properties(self):\n        \"\"\"Test event status properties\"\"\"\n        # Upcoming event\n        upcoming_event = Event.objects.create(**self.event_data)\n        self.assertTrue(upcoming_event.is_upcoming)\n        self.assertFalse(upcoming_event.is_ongoing)\n        self.assertFalse(upcoming_event.is_past)\n        \n        # Ongoing event\n        ongoing_data = self.event_data.copy()\n        ongoing_data['start_datetime'] = timezone.now() - timedelta(hours=1)\n        ongoing_data['end_datetime'] = timezone.now() + timedelta(hours=2)\n        ongoing_event = Event.objects.create(**ongoing_data)\n        \n        self.assertFalse(ongoing_event.is_upcoming)\n        self.assertTrue(ongoing_event.is_ongoing)\n        self.assertFalse(ongoing_event.is_past)\n        \n        # Past event\n        past_data = self.event_data.copy()\n        past_data['start_datetime'] = timezone.now() - timedelta(days=2)\n        past_data['end_datetime'] = timezone.now() - timedelta(days=2, hours=-3)\n        past_event = Event.objects.create(**past_data)\n        \n        self.assertFalse(past_event.is_upcoming)\n        self.assertFalse(past_event.is_ongoing)\n        self.assertTrue(past_event.is_past)\n    \n    def test_available_spots_property(self):\n        \"\"\"Test available spots calculation\"\"\"\n        event = Event.objects.create(**self.event_data)\n        \n        # Initially all spots should be available\n        self.assertEqual(event.available_spots, event.max_attendees)\n        self.assertTrue(event.tickets_available)\n\nclass EventAPITest(APITestCase):\n    \"\"\"\n    Test cases for Event API endpoints\n    \"\"\"\n    \n    def setUp(self):\n        self.participant = User.objects.create_user(\n            email='participant@example.com',\n            password='testpass123',\n            first_name='John',\n            last_name='Participant',\n            role='participant'\n        )\n        \n        self.organizer = User.objects.create_user(\n            email='organizer@example.com',\n            password='testpass123',\n            first_name='Jane',\n            last_name='Organizer',\n            role='organizer'\n        )\n        \n        self.admin = User.objects.create_user(\n            email='admin@example.com',\n            password='testpass123',\n            first_name='Admin',\n            last_name='User',\n            role='admin'\n        )\n        \n        self.event_data = {\n            'title': 'Test Event',\n            'description': 'Test event description',\n            'start_datetime': (timezone.now() + timedelta(days=7)).isoformat(),\n            'end_datetime': (timezone.now() + timedelta(days=7, hours=3)).isoformat(),\n            'location': 'Cotonou',\n            'category': 'music',\n            'max_attendees': 100\n        }\n        \n        self.event = Event.objects.create(\n            title='Existing Event',\n            description='Existing event description',\n            start_datetime=timezone.now() + timedelta(days=14),\n            end_datetime=timezone.now() + timedelta(days=14, hours=3),\n            location='Porto-Novo',\n            category='conference',\n            max_attendees=50,\n            organizer=self.organizer\n        )\n    \n    def test_list_events_unauthenticated(self):\n        \"\"\"Test listing events without authentication\"\"\"\n        url = reverse('event-list')\n        response = self.client.get(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertGreaterEqual(len(response.data['results']), 1)\n    \n    def test_create_event_as_organizer(self):\n        \"\"\"Test creating event as organizer\"\"\"\n        self.client.force_authenticate(user=self.organizer)\n        url = reverse('event-list')\n        response = self.client.post(url, self.event_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n        self.assertEqual(response.data['title'], self.event_data['title'])\n        self.assertEqual(response.data['organizer']['id'], self.organizer.id)\n    \n    def test_create_event_as_participant(self):\n        \"\"\"Test creating event as participant (should fail)\"\"\"\n        self.client.force_authenticate(user=self.participant)\n        url = reverse('event-list')\n        response = self.client.post(url, self.event_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n    \n    def test_create_event_as_admin(self):\n        \"\"\"Test creating event as admin\"\"\"\n        self.client.force_authenticate(user=self.admin)\n        url = reverse('event-list')\n        response = self.client.post(url, self.event_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n    \n    def test_update_event_as_organizer(self):\n        \"\"\"Test updating own event as organizer\"\"\"\n        self.client.force_authenticate(user=self.organizer)\n        url = reverse('event-detail', kwargs={'pk': self.event.id})\n        \n        update_data = {\n            'title': 'Updated Event Title',\n            'max_attendees': 75\n        }\n        \n        response = self.client.patch(url, update_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(response.data['title'], update_data['title'])\n        self.assertEqual(response.data['max_attendees'], update_data['max_attendees'])\n    \n    def test_update_other_organizer_event(self):\n        \"\"\"Test updating another organizer's event (should fail)\"\"\"\n        other_organizer = User.objects.create_user(\n            email='other@example.com',\n            password='testpass123',\n            first_name='Other',\n            last_name='Organizer',\n            role='organizer'\n        )\n        \n        self.client.force_authenticate(user=other_organizer)\n        url = reverse('event-detail', kwargs={'pk': self.event.id})\n        \n        update_data = {'title': 'Hacked Title'}\n        response = self.client.patch(url, update_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_404_NOT_FOUND)\n    \n    def test_delete_event_as_organizer(self):\n        \"\"\"Test deleting own event as organizer\"\"\"\n        self.client.force_authenticate(user=self.organizer)\n        url = reverse('event-detail', kwargs={'pk': self.event.id})\n        response = self.client.delete(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)\n        \n        # Event should be soft deleted (is_active = False)\n        self.event.refresh_from_db()\n        self.assertFalse(self.event.is_active)\n    \n    def test_search_events(self):\n        \"\"\"Test searching events\"\"\"\n        url = reverse('event-list')\n        response = self.client.get(url, {'search': 'Existing'})\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertGreaterEqual(len(response.data['results']), 1)\n        \n        # Check if the searched event is in results\n        event_titles = [event['title'] for event in response.data['results']]\n        self.assertIn('Existing Event', event_titles)\n    \n    def test_filter_events_by_category(self):\n        \"\"\"Test filtering events by category\"\"\"\n        url = reverse('event-list')\n        response = self.client.get(url, {'category': 'conference'})\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        \n        # All returned events should be conference category\n        for event in response.data['results']:\n            self.assertEqual(event['category'], 'conference')\n    \n    def test_get_event_details(self):\n        \"\"\"Test getting event details\"\"\"\n        url = reverse('event-detail', kwargs={'pk': self.event.id})\n        response = self.client.get(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(response.data['id'], self.event.id)\n        self.assertEqual(response.data['title'], self.event.title)\n    \n    def test_event_stats_as_organizer(self):\n        \"\"\"Test getting event stats as organizer\"\"\"\n        self.client.force_authenticate(user=self.organizer)\n        url = reverse('event-stats', kwargs={'pk': self.event.id})\n        response = self.client.get(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertIn('total_tickets_sold', response.data)\n        self.assertIn('total_revenue', response.data)\n        self.assertIn('available_spots', response.data)\n    \n    def test_event_stats_as_participant(self):\n        \"\"\"Test getting event stats as participant (should fail)\"\"\"\n        self.client.force_authenticate(user=self.participant)\n        url = reverse('event-stats', kwargs={'pk': self.event.id})\n        response = self.client.get(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n","size_bytes":10668},"apps/events/urls.py":{"content":"from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom rest_framework_nested import routers\n\nfrom .views import EventViewSet, EventReviewViewSet\n\n# Create router for events\nrouter = DefaultRouter()\nrouter.register(r'', EventViewSet, basename='event')\n\n# Create nested router for event reviews\nevents_router = routers.NestedDefaultRouter(router, r'', lookup='event')\nevents_router.register(r'reviews', EventReviewViewSet, basename='event-reviews')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    path('', include(events_router.urls)),\n]\n","size_bytes":582},"apps/events/views.py":{"content":"from rest_framework import generics, status, permissions, filters\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom rest_framework.viewsets import ModelViewSet\nfrom django_filters.rest_framework import DjangoFilterBackend\nfrom django.db.models import Q\nfrom django.utils import timezone\nfrom drf_spectacular.utils import extend_schema, OpenApiParameter, OpenApiResponse\n\nfrom .models import Event, EventReview\nfrom .serializers import (\n    EventSerializer,\n    EventListSerializer, \n    EventCreateUpdateSerializer,\n    EventReviewSerializer\n)\nfrom apps.tickets.models import Ticket\n\nclass EventPermission(permissions.BasePermission):\n    \"\"\"\n    Custom permission for events:\n    - Anyone can read events\n    - Only organizers can create events\n    - Only event organizers can update/delete their own events\n    - Admins can do everything\n    \"\"\"\n    \n    def has_permission(self, request, view):\n        if request.method in permissions.SAFE_METHODS:\n            return True\n        \n        if not request.user.is_authenticated:\n            return False\n        \n        if request.method == 'POST':\n            return request.user.role in ['organizer', 'admin']\n        \n        return True\n    \n    def has_object_permission(self, request, view, obj):\n        if request.method in permissions.SAFE_METHODS:\n            return True\n        \n        if request.user.role == 'admin':\n            return True\n        \n        return obj.organizer == request.user\n\nclass EventFilter(filters.BaseFilterBackend):\n    \"\"\"\n    Custom filter for events\n    \"\"\"\n    \n    def filter_queryset(self, request, queryset, view):\n        # Filter by search query (title, description, location)\n        search = request.query_params.get('search')\n        if search:\n            queryset = queryset.filter(\n                Q(title__icontains=search) |\n                Q(description__icontains=search) |\n                Q(location__icontains=search)\n            )\n        \n        # Filter by category\n        category = request.query_params.get('category')\n        if category:\n            queryset = queryset.filter(category=category)\n        \n        # Filter by location\n        location = request.query_params.get('location')\n        if location:\n            queryset = queryset.filter(location__icontains=location)\n        \n        # Filter by date range\n        start_date = request.query_params.get('start_date')\n        end_date = request.query_params.get('end_date')\n        \n        if start_date:\n            try:\n                start_datetime = timezone.datetime.fromisoformat(start_date)\n                queryset = queryset.filter(start_datetime__gte=start_datetime)\n            except ValueError:\n                pass\n        \n        if end_date:\n            try:\n                end_datetime = timezone.datetime.fromisoformat(end_date)\n                queryset = queryset.filter(end_datetime__lte=end_datetime)\n            except ValueError:\n                pass\n        \n        # Filter by status\n        status_filter = request.query_params.get('status')\n        if status_filter == 'upcoming':\n            queryset = queryset.filter(start_datetime__gt=timezone.now())\n        elif status_filter == 'ongoing':\n            now = timezone.now()\n            queryset = queryset.filter(\n                start_datetime__lte=now,\n                end_datetime__gte=now\n            )\n        elif status_filter == 'past':\n            queryset = queryset.filter(end_datetime__lt=timezone.now())\n        \n        # Filter by featured events\n        featured = request.query_params.get('featured')\n        if featured and featured.lower() == 'true':\n            queryset = queryset.filter(is_featured=True)\n        \n        return queryset\n\nclass EventViewSet(ModelViewSet):\n    \"\"\"\n    ViewSet for managing events\n    \"\"\"\n    queryset = Event.objects.filter(is_active=True).select_related('organizer').prefetch_related('images', 'reviews')\n    permission_classes = [EventPermission]\n    filter_backends = [EventFilter, DjangoFilterBackend, filters.OrderingFilter]\n    filterset_fields = ['category', 'is_featured']\n    ordering_fields = ['start_datetime', 'created_at', 'title']\n    ordering = ['-created_at']\n    \n    def get_serializer_class(self):\n        if self.action == 'list':\n            return EventListSerializer\n        elif self.action in ['create', 'update', 'partial_update']:\n            return EventCreateUpdateSerializer\n        return EventSerializer\n    \n    def get_queryset(self):\n        queryset = super().get_queryset()\n        \n        # Organizers see only their own events when creating/updating\n        if self.action in ['update', 'partial_update', 'destroy']:\n            if self.request.user.role == 'organizer':\n                queryset = queryset.filter(organizer=self.request.user)\n        \n        return queryset\n    \n    @extend_schema(\n        summary=\"List Events\",\n        description=\"Get list of events with filtering and search\",\n        parameters=[\n            OpenApiParameter(name='search', description='Search in title, description, location'),\n            OpenApiParameter(name='category', description='Filter by category'),\n            OpenApiParameter(name='location', description='Filter by location'),\n            OpenApiParameter(name='start_date', description='Filter events starting from this date'),\n            OpenApiParameter(name='end_date', description='Filter events ending before this date'),\n            OpenApiParameter(name='status', description='Filter by status: upcoming, ongoing, past'),\n            OpenApiParameter(name='featured', description='Filter featured events'),\n        ]\n    )\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Create Event\",\n        description=\"Create a new event (organizers and admins only)\",\n        request=EventCreateUpdateSerializer,\n        responses={201: EventSerializer}\n    )\n    def create(self, request, *args, **kwargs):\n        return super().create(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Get Event Details\",\n        description=\"Get detailed information about a specific event\",\n        responses={200: EventSerializer}\n    )\n    def retrieve(self, request, *args, **kwargs):\n        return super().retrieve(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Update Event\",\n        description=\"Update event details (event organizer or admin only)\",\n        request=EventCreateUpdateSerializer,\n        responses={200: EventSerializer}\n    )\n    def update(self, request, *args, **kwargs):\n        return super().update(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Partially Update Event\",\n        description=\"Partially update event details (event organizer or admin only)\",\n        request=EventCreateUpdateSerializer,\n        responses={200: EventSerializer}\n    )\n    def partial_update(self, request, *args, **kwargs):\n        return super().partial_update(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Delete Event\",\n        description=\"Delete an event (event organizer or admin only)\",\n        responses={204: OpenApiResponse(description=\"Event deleted successfully\")}\n    )\n    def destroy(self, request, *args, **kwargs):\n        event = self.get_object()\n        \n        # Check if event has sold tickets\n        if event.total_tickets_sold > 0:\n            return Response({\n                'error': 'Cannot delete event with sold tickets'\n            }, status=status.HTTP_400_BAD_REQUEST)\n        \n        # Soft delete by setting is_active to False\n        event.is_active = False\n        event.save()\n        \n        return Response(status=status.HTTP_204_NO_CONTENT)\n    \n    @extend_schema(\n        summary=\"Get Event Tickets\",\n        description=\"Get available tickets for an event\",\n        responses={200: \"List of tickets\"}\n    )\n    @action(detail=True, methods=['get'])\n    def tickets(self, request, pk=None):\n        \"\"\"Get tickets for this event\"\"\"\n        event = self.get_object()\n        tickets = Ticket.objects.filter(event=event, is_active=True)\n        \n        from apps.tickets.serializers import TicketSerializer\n        serializer = TicketSerializer(tickets, many=True, context={'request': request})\n        return Response(serializer.data)\n    \n    @extend_schema(\n        summary=\"Get Event Stats\",\n        description=\"Get event statistics (event organizer or admin only)\",\n        responses={200: \"Event statistics\"}\n    )\n    @action(detail=True, methods=['get'], permission_classes=[permissions.IsAuthenticated])\n    def stats(self, request, pk=None):\n        \"\"\"Get event statistics\"\"\"\n        event = self.get_object()\n        \n        # Check permission\n        if request.user.role not in ['admin'] and event.organizer != request.user:\n            return Response({\n                'error': 'Permission denied'\n            }, status=status.HTTP_403_FORBIDDEN)\n        \n        stats = {\n            'total_tickets_sold': event.total_tickets_sold,\n            'total_revenue': float(event.total_revenue),\n            'available_spots': event.available_spots,\n            'attendance_rate': (event.total_tickets_sold / event.max_attendees * 100) if event.max_attendees > 0 else 0,\n            'tickets_by_type': []\n        }\n        \n        # Get ticket sales by type\n        tickets = Ticket.objects.filter(event=event)\n        for ticket in tickets:\n            ticket_stats = {\n                'ticket_name': ticket.name,\n                'price': float(ticket.price),\n                'quantity_sold': ticket.quantity_sold,\n                'quantity_available': ticket.quantity_available,\n                'revenue': float(ticket.quantity_sold * ticket.price)\n            }\n            stats['tickets_by_type'].append(ticket_stats)\n        \n        return Response(stats)\n\nclass EventReviewViewSet(ModelViewSet):\n    \"\"\"\n    ViewSet for managing event reviews\n    \"\"\"\n    serializer_class = EventReviewSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_queryset(self):\n        event_id = self.kwargs.get('event_pk')\n        return EventReview.objects.filter(event_id=event_id).select_related('user', 'event')\n    \n    def perform_create(self, serializer):\n        event_id = self.kwargs.get('event_pk')\n        event = Event.objects.get(id=event_id)\n        serializer.save(user=self.request.user, event=event)\n    \n    def create(self, request, *args, **kwargs):\n        event_id = self.kwargs.get('event_pk')\n        \n        # Check if user has already reviewed this event\n        if EventReview.objects.filter(event_id=event_id, user=request.user).exists():\n            return Response({\n                'error': 'You have already reviewed this event'\n            }, status=status.HTTP_400_BAD_REQUEST)\n        \n        # Check if event exists and has ended\n        try:\n            event = Event.objects.get(id=event_id)\n            if not event.is_past:\n                return Response({\n                    'error': 'You can only review events that have ended'\n                }, status=status.HTTP_400_BAD_REQUEST)\n        except Event.DoesNotExist:\n            return Response({\n                'error': 'Event not found'\n            }, status=status.HTTP_404_NOT_FOUND)\n        \n        return super().create(request, *args, **kwargs)\n","size_bytes":11470},"apps/notifications/__init__.py":{"content":"","size_bytes":0},"apps/notifications/models.py":{"content":"from django.db import models\nfrom django.contrib.auth import get_user_model\nimport uuid\n\nUser = get_user_model()\n\nclass NotificationTemplate(models.Model):\n    \"\"\"\n    Model for storing notification templates\n    \"\"\"\n    NOTIFICATION_TYPES = [\n        ('email', 'Email'),\n        ('push', 'Push Notification'),\n        ('sms', 'SMS'),\n    ]\n    \n    EVENT_TYPES = [\n        ('user_registration', 'User Registration'),\n        ('purchase_confirmation', 'Purchase Confirmation'),\n        ('purchase_cancellation', 'Purchase Cancellation'),\n        ('event_reminder', 'Event Reminder'),\n        ('event_cancelled', 'Event Cancelled'),\n        ('event_updated', 'Event Updated'),\n        ('refund_request', 'Refund Request'),\n        ('refund_approved', 'Refund Approved'),\n        ('refund_rejected', 'Refund Rejected'),\n        ('payment_failed', 'Payment Failed'),\n        ('ticket_validation', 'Ticket Validation'),\n    ]\n    \n    name = models.CharField(max_length=100)\n    notification_type = models.CharField(max_length=20, choices=NOTIFICATION_TYPES)\n    event_type = models.CharField(max_length=50, choices=EVENT_TYPES)\n    \n    # Template content\n    subject = models.CharField(max_length=200, blank=True)  # For email/SMS\n    content = models.TextField()\n    html_content = models.TextField(blank=True)  # For email\n    \n    # Settings\n    is_active = models.BooleanField(default=True)\n    send_to_user = models.BooleanField(default=True)\n    send_to_organizer = models.BooleanField(default=False)\n    send_to_admin = models.BooleanField(default=False)\n    \n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        db_table = 'notification_templates'\n        verbose_name = 'Notification Template'\n        verbose_name_plural = 'Notification Templates'\n        unique_together = ['notification_type', 'event_type']\n    \n    def __str__(self):\n        return f\"{self.get_notification_type_display()} - {self.get_event_type_display()}\"\n\nclass Notification(models.Model):\n    \"\"\"\n    Model for storing sent notifications\n    \"\"\"\n    STATUS_CHOICES = [\n        ('pending', 'Pending'),\n        ('sending', 'Sending'),\n        ('sent', 'Sent'),\n        ('failed', 'Failed'),\n        ('delivered', 'Delivered'),\n        ('opened', 'Opened'),\n    ]\n    \n    # Identification\n    notification_id = models.UUIDField(default=uuid.uuid4, unique=True, editable=False)\n    \n    # Recipient\n    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='notifications')\n    \n    # Content\n    notification_type = models.CharField(max_length=20, choices=NotificationTemplate.NOTIFICATION_TYPES)\n    event_type = models.CharField(max_length=50, choices=NotificationTemplate.EVENT_TYPES)\n    subject = models.CharField(max_length=200, blank=True)\n    content = models.TextField()\n    html_content = models.TextField(blank=True)\n    \n    # Delivery details\n    recipient_email = models.EmailField(blank=True)\n    recipient_phone = models.CharField(max_length=20, blank=True)\n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')\n    \n    # Related objects\n    related_event = models.ForeignKey('events.Event', on_delete=models.SET_NULL, null=True, blank=True)\n    related_purchase = models.ForeignKey('tickets.Purchase', on_delete=models.SET_NULL, null=True, blank=True)\n    related_payment = models.ForeignKey('payments.Payment', on_delete=models.SET_NULL, null=True, blank=True)\n    \n    # Provider details\n    provider_id = models.CharField(max_length=100, blank=True)  # External provider message ID\n    provider_response = models.JSONField(blank=True, null=True)\n    error_message = models.TextField(blank=True)\n    \n    # Delivery tracking\n    sent_at = models.DateTimeField(null=True, blank=True)\n    delivered_at = models.DateTimeField(null=True, blank=True)\n    opened_at = models.DateTimeField(null=True, blank=True)\n    \n    # Timestamps\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        db_table = 'notifications'\n        verbose_name = 'Notification'\n        verbose_name_plural = 'Notifications'\n        ordering = ['-created_at']\n        indexes = [\n            models.Index(fields=['user', 'status']),\n            models.Index(fields=['notification_type', 'status']),\n            models.Index(fields=['event_type']),\n            models.Index(fields=['created_at']),\n        ]\n    \n    def __str__(self):\n        return f\"{self.get_notification_type_display()} to {self.user.email} - {self.get_event_type_display()}\"\n    \n    @property\n    def is_sent(self):\n        \"\"\"Check if notification was sent\"\"\"\n        return self.status in ['sent', 'delivered', 'opened']\n    \n    @property\n    def is_delivered(self):\n        \"\"\"Check if notification was delivered\"\"\"\n        return self.status in ['delivered', 'opened']\n    \n    def mark_as_sent(self, provider_id='', provider_response=None):\n        \"\"\"Mark notification as sent\"\"\"\n        from django.utils import timezone\n        \n        self.status = 'sent'\n        self.sent_at = timezone.now()\n        self.provider_id = provider_id\n        self.provider_response = provider_response\n        self.save()\n    \n    def mark_as_failed(self, error_message=''):\n        \"\"\"Mark notification as failed\"\"\"\n        self.status = 'failed'\n        self.error_message = error_message\n        self.save()\n    \n    def mark_as_delivered(self):\n        \"\"\"Mark notification as delivered\"\"\"\n        from django.utils import timezone\n        \n        self.status = 'delivered'\n        self.delivered_at = timezone.now()\n        self.save()\n    \n    def mark_as_opened(self):\n        \"\"\"Mark notification as opened\"\"\"\n        from django.utils import timezone\n        \n        self.status = 'opened'\n        self.opened_at = timezone.now()\n        self.save()\n\nclass NotificationPreference(models.Model):\n    \"\"\"\n    Model for user notification preferences\n    \"\"\"\n    user = models.OneToOneField(User, on_delete=models.CASCADE, related_name='notification_preferences')\n    \n    # Email preferences\n    email_purchase_confirmation = models.BooleanField(default=True)\n    email_event_reminders = models.BooleanField(default=True)\n    email_event_updates = models.BooleanField(default=True)\n    email_marketing = models.BooleanField(default=False)\n    \n    # Push notification preferences\n    push_purchase_confirmation = models.BooleanField(default=True)\n    push_event_reminders = models.BooleanField(default=True)\n    push_event_updates = models.BooleanField(default=True)\n    \n    # SMS preferences\n    sms_purchase_confirmation = models.BooleanField(default=False)\n    sms_event_reminders = models.BooleanField(default=False)\n    \n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        db_table = 'notification_preferences'\n        verbose_name = 'Notification Preference'\n        verbose_name_plural = 'Notification Preferences'\n    \n    def __str__(self):\n        return f\"Preferences for {self.user.email}\"\n    \n    def allows_notification(self, notification_type, event_type):\n        \"\"\"Check if user allows a specific notification\"\"\"\n        preference_key = f\"{notification_type}_{event_type}\"\n        return getattr(self, preference_key, True)\n\nclass NotificationLog(models.Model):\n    \"\"\"\n    Model for logging notification events\n    \"\"\"\n    notification = models.ForeignKey(Notification, on_delete=models.CASCADE, related_name='logs')\n    event_type = models.CharField(max_length=50)  # e.g., 'send_attempt', 'delivery_update', 'open_tracking'\n    message = models.TextField()\n    data = models.JSONField(blank=True, null=True)\n    \n    created_at = models.DateTimeField(auto_now_add=True)\n    \n    class Meta:\n        db_table = 'notification_logs'\n        verbose_name = 'Notification Log'\n        verbose_name_plural = 'Notification Logs'\n        ordering = ['-created_at']\n    \n    def __str__(self):\n        return f\"{self.notification.notification_id} - {self.event_type}\"\n","size_bytes":8134},"apps/notifications/serializers.py":{"content":"from rest_framework import serializers\nfrom .models import Notification, NotificationTemplate, NotificationPreference, NotificationLog\n\nclass NotificationSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Notification model\n    \"\"\"\n    user = serializers.StringRelatedField(read_only=True)\n    related_event = serializers.StringRelatedField(read_only=True)\n    related_purchase = serializers.StringRelatedField(read_only=True)\n    is_sent = serializers.ReadOnlyField()\n    is_delivered = serializers.ReadOnlyField()\n    \n    class Meta:\n        model = Notification\n        fields = [\n            'id', 'notification_id', 'user', 'notification_type', 'event_type',\n            'subject', 'content', 'recipient_email', 'recipient_phone', 'status',\n            'related_event', 'related_purchase', 'provider_id', 'error_message',\n            'is_sent', 'is_delivered', 'sent_at', 'delivered_at', 'opened_at',\n            'created_at', 'updated_at'\n        ]\n        read_only_fields = [\n            'id', 'notification_id', 'user', 'provider_id', 'error_message',\n            'is_sent', 'is_delivered', 'sent_at', 'delivered_at', 'opened_at',\n            'created_at', 'updated_at'\n        ]\n\nclass NotificationTemplateSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Notification Template model\n    \"\"\"\n    class Meta:\n        model = NotificationTemplate\n        fields = [\n            'id', 'name', 'notification_type', 'event_type', 'subject',\n            'content', 'html_content', 'is_active', 'send_to_user',\n            'send_to_organizer', 'send_to_admin', 'created_at', 'updated_at'\n        ]\n        read_only_fields = ['id', 'created_at', 'updated_at']\n\nclass NotificationPreferenceSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Notification Preference model\n    \"\"\"\n    user = serializers.StringRelatedField(read_only=True)\n    \n    class Meta:\n        model = NotificationPreference\n        fields = [\n            'id', 'user', 'email_purchase_confirmation', 'email_event_reminders',\n            'email_event_updates', 'email_marketing', 'push_purchase_confirmation',\n            'push_event_reminders', 'push_event_updates', 'sms_purchase_confirmation',\n            'sms_event_reminders', 'created_at', 'updated_at'\n        ]\n        read_only_fields = ['id', 'user', 'created_at', 'updated_at']\n\nclass NotificationLogSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Notification Log model\n    \"\"\"\n    class Meta:\n        model = NotificationLog\n        fields = ['id', 'event_type', 'message', 'data', 'created_at']\n        read_only_fields = ['id', 'created_at']\n\nclass NotificationStatsSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for notification statistics\n    \"\"\"\n    total_notifications = serializers.IntegerField()\n    notifications_by_type = serializers.DictField()\n    notifications_by_status = serializers.DictField()\n    delivery_rate = serializers.FloatField()\n    open_rate = serializers.FloatField()\n    recent_notifications = NotificationSerializer(many=True)\n\nclass BulkNotificationSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for sending bulk notifications\n    \"\"\"\n    event_type = serializers.ChoiceField(choices=NotificationTemplate.EVENT_TYPES)\n    notification_type = serializers.ChoiceField(choices=NotificationTemplate.NOTIFICATION_TYPES)\n    subject = serializers.CharField(max_length=200, required=False)\n    content = serializers.CharField()\n    html_content = serializers.CharField(required=False, allow_blank=True)\n    \n    # Recipient filters\n    user_roles = serializers.MultipleChoiceField(\n        choices=[('participant', 'Participant'), ('organizer', 'Organizer'), ('admin', 'Admin')],\n        required=False\n    )\n    event_id = serializers.IntegerField(required=False)\n    \n    def validate(self, attrs):\n        notification_type = attrs.get('notification_type')\n        \n        if notification_type == 'email' and not attrs.get('subject'):\n            raise serializers.ValidationError({\n                'subject': 'Subject is required for email notifications'\n            })\n        \n        return attrs\n","size_bytes":4163},"apps/notifications/urls.py":{"content":"from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\n\nfrom .views import NotificationViewSet, NotificationTemplateViewSet, NotificationPreferenceViewSet\n\nrouter = DefaultRouter()\nrouter.register(r'notifications', NotificationViewSet, basename='notification')\nrouter.register(r'templates', NotificationTemplateViewSet, basename='notification-template')\nrouter.register(r'preferences', NotificationPreferenceViewSet, basename='notification-preference')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n","size_bytes":540},"apps/notifications/views.py":{"content":"from rest_framework import viewsets, status, permissions\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom django.db.models import Count, Q\nfrom django.utils import timezone\nfrom drf_spectacular.utils import extend_schema, OpenApiResponse\nfrom datetime import timedelta\n\nfrom .models import Notification, NotificationTemplate, NotificationPreference\nfrom .serializers import (\n    NotificationSerializer,\n    NotificationTemplateSerializer,\n    NotificationPreferenceSerializer,\n    NotificationStatsSerializer,\n    BulkNotificationSerializer\n)\nfrom .services import NotificationService\n\nclass NotificationPermission(permissions.BasePermission):\n    \"\"\"\n    Custom permission for notifications:\n    - Users can view their own notifications\n    - Admins can view all notifications and manage templates\n    \"\"\"\n    \n    def has_permission(self, request, view):\n        return request.user.is_authenticated\n    \n    def has_object_permission(self, request, view, obj):\n        if request.user.role == 'admin':\n            return True\n        \n        if hasattr(obj, 'user'):\n            return obj.user == request.user\n        \n        return False\n\nclass NotificationViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    ViewSet for viewing notifications\n    \"\"\"\n    serializer_class = NotificationSerializer\n    permission_classes = [NotificationPermission]\n    \n    def get_queryset(self):\n        user = self.request.user\n        \n        if user.role == 'admin':\n            return Notification.objects.all().select_related('user', 'related_event', 'related_purchase')\n        else:\n            return Notification.objects.filter(user=user).select_related('related_event', 'related_purchase')\n    \n    @extend_schema(\n        summary=\"List Notifications\",\n        description=\"Get list of notifications for the authenticated user\",\n        responses={200: NotificationSerializer(many=True)}\n    )\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Get Notification Details\",\n        description=\"Get detailed information about a specific notification\",\n        responses={200: NotificationSerializer}\n    )\n    def retrieve(self, request, *args, **kwargs):\n        # Mark notification as opened if it's an email\n        notification = self.get_object()\n        if notification.notification_type == 'email' and notification.status == 'delivered':\n            notification.mark_as_opened()\n        \n        return super().retrieve(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Mark as Read\",\n        description=\"Mark notification as read/opened\",\n        responses={200: NotificationSerializer}\n    )\n    @action(detail=True, methods=['post'])\n    def mark_read(self, request, pk=None):\n        \"\"\"Mark notification as read\"\"\"\n        notification = self.get_object()\n        \n        if notification.status in ['sent', 'delivered']:\n            notification.mark_as_opened()\n        \n        return Response(\n            NotificationSerializer(notification, context={'request': request}).data\n        )\n    \n    @extend_schema(\n        summary=\"Get Notification Statistics\",\n        description=\"Get notification statistics (admin only)\",\n        responses={200: NotificationStatsSerializer}\n    )\n    @action(detail=False, methods=['get'])\n    def stats(self, request):\n        \"\"\"Get notification statistics\"\"\"\n        if request.user.role != 'admin':\n            return Response({\n                'error': 'Permission denied'\n            }, status=status.HTTP_403_FORBIDDEN)\n        \n        # Calculate statistics\n        total_notifications = Notification.objects.count()\n        \n        # Notifications by type\n        notifications_by_type = dict(\n            Notification.objects.values('notification_type').annotate(\n                count=Count('id')\n            ).values_list('notification_type', 'count')\n        )\n        \n        # Notifications by status\n        notifications_by_status = dict(\n            Notification.objects.values('status').annotate(\n                count=Count('id')\n            ).values_list('status', 'count')\n        )\n        \n        # Calculate delivery and open rates\n        sent_count = Notification.objects.filter(status__in=['sent', 'delivered', 'opened']).count()\n        delivered_count = Notification.objects.filter(status__in=['delivered', 'opened']).count()\n        opened_count = Notification.objects.filter(status='opened').count()\n        \n        delivery_rate = (delivered_count / sent_count * 100) if sent_count > 0 else 0\n        open_rate = (opened_count / delivered_count * 100) if delivered_count > 0 else 0\n        \n        # Recent notifications\n        recent_notifications = Notification.objects.all()[:10]\n        \n        stats = {\n            'total_notifications': total_notifications,\n            'notifications_by_type': notifications_by_type,\n            'notifications_by_status': notifications_by_status,\n            'delivery_rate': delivery_rate,\n            'open_rate': open_rate,\n            'recent_notifications': NotificationSerializer(recent_notifications, many=True, context={'request': request}).data\n        }\n        \n        serializer = NotificationStatsSerializer(stats)\n        return Response(serializer.data)\n    \n    @extend_schema(\n        summary=\"Send Bulk Notification\",\n        description=\"Send bulk notifications to users (admin only)\",\n        request=BulkNotificationSerializer,\n        responses={200: OpenApiResponse(description=\"Bulk notification sent successfully\")}\n    )\n    @action(detail=False, methods=['post'])\n    def send_bulk(self, request):\n        \"\"\"Send bulk notifications\"\"\"\n        if request.user.role != 'admin':\n            return Response({\n                'error': 'Permission denied'\n            }, status=status.HTTP_403_FORBIDDEN)\n        \n        serializer = BulkNotificationSerializer(data=request.data)\n        \n        if serializer.is_valid():\n            try:\n                notification_service = NotificationService()\n                result = notification_service.send_bulk_notification(serializer.validated_data)\n                \n                return Response({\n                    'message': 'Bulk notification sent successfully',\n                    'sent_count': result.get('sent_count', 0),\n                    'failed_count': result.get('failed_count', 0)\n                })\n            \n            except Exception as e:\n                return Response({\n                    'error': 'Failed to send bulk notification',\n                    'details': str(e)\n                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\nclass NotificationTemplateViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    ViewSet for managing notification templates (admin only)\n    \"\"\"\n    queryset = NotificationTemplate.objects.all()\n    serializer_class = NotificationTemplateSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_permissions(self):\n        \"\"\"Only admins can manage templates\"\"\"\n        if self.request.user.is_authenticated and self.request.user.role == 'admin':\n            return [permissions.IsAuthenticated()]\n        return [permissions.DenyAll()]\n    \n    @extend_schema(\n        summary=\"List Notification Templates\",\n        description=\"Get list of notification templates (admin only)\",\n        responses={200: NotificationTemplateSerializer(many=True)}\n    )\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Create Notification Template\",\n        description=\"Create a new notification template (admin only)\",\n        request=NotificationTemplateSerializer,\n        responses={201: NotificationTemplateSerializer}\n    )\n    def create(self, request, *args, **kwargs):\n        return super().create(request, *args, **kwargs)\n\nclass NotificationPreferenceViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    ViewSet for managing user notification preferences\n    \"\"\"\n    serializer_class = NotificationPreferenceSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_queryset(self):\n        return NotificationPreference.objects.filter(user=self.request.user)\n    \n    def get_object(self):\n        \"\"\"Get or create notification preferences for the user\"\"\"\n        preferences, created = NotificationPreference.objects.get_or_create(\n            user=self.request.user\n        )\n        return preferences\n    \n    @extend_schema(\n        summary=\"Get Notification Preferences\",\n        description=\"Get current user's notification preferences\",\n        responses={200: NotificationPreferenceSerializer}\n    )\n    def retrieve(self, request, *args, **kwargs):\n        return super().retrieve(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Update Notification Preferences\",\n        description=\"Update current user's notification preferences\",\n        request=NotificationPreferenceSerializer,\n        responses={200: NotificationPreferenceSerializer}\n    )\n    def update(self, request, *args, **kwargs):\n        return super().update(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Partially Update Notification Preferences\",\n        description=\"Partially update current user's notification preferences\",\n        request=NotificationPreferenceSerializer,\n        responses={200: NotificationPreferenceSerializer}\n    )\n    def partial_update(self, request, *args, **kwargs):\n        return super().partial_update(request, *args, **kwargs)\n    \n    @action(detail=False, methods=['get'])\n    def me(self, request):\n        \"\"\"Get current user's notification preferences\"\"\"\n        preferences = self.get_object()\n        serializer = self.get_serializer(preferences)\n        return Response(serializer.data)\n","size_bytes":9992},"apps/payments/__init__.py":{"content":"","size_bytes":0},"apps/payments/models.py":{"content":"from django.db import models\nfrom django.contrib.auth import get_user_model\nfrom decimal import Decimal\nimport uuid\n\nUser = get_user_model()\n\nclass Payment(models.Model):\n    \"\"\"\n    Payment model for tracking all payment transactions\n    \"\"\"\n    PAYMENT_METHODS = [\n        ('mobile_money', 'Mobile Money'),\n        ('card', 'Card Payment'),\n    ]\n    \n    STATUS_CHOICES = [\n        ('pending', 'Pending'),\n        ('processing', 'Processing'),\n        ('success', 'Success'),\n        ('failed', 'Failed'),\n        ('cancelled', 'Cancelled'),\n        ('refunded', 'Refunded'),\n    ]\n    \n    # Payment identification\n    payment_reference = models.CharField(max_length=100, unique=True, editable=False)\n    external_reference = models.CharField(max_length=100, blank=True)  # From payment provider\n    \n    # Payment details\n    amount = models.DecimalField(max_digits=10, decimal_places=2)\n    currency = models.CharField(max_length=3, default='XOF')  # West African CFA franc\n    method = models.CharField(max_length=20, choices=PAYMENT_METHODS)\n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')\n    \n    # Related models\n    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='payments')\n    purchase = models.ForeignKey('tickets.Purchase', on_delete=models.CASCADE, related_name='payments', null=True, blank=True)\n    \n    # Payment method specific data\n    mobile_money_phone = models.CharField(max_length=20, blank=True)\n    mobile_money_provider = models.CharField(max_length=50, blank=True)\n    \n    card_last_four = models.CharField(max_length=4, blank=True)\n    card_brand = models.CharField(max_length=20, blank=True)\n    \n    # Provider response data\n    provider_response = models.JSONField(blank=True, null=True)\n    failure_reason = models.TextField(blank=True)\n    \n    # Timestamps\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    processed_at = models.DateTimeField(null=True, blank=True)\n    \n    class Meta:\n        db_table = 'payments'\n        verbose_name = 'Payment'\n        verbose_name_plural = 'Payments'\n        ordering = ['-created_at']\n        indexes = [\n            models.Index(fields=['payment_reference']),\n            models.Index(fields=['external_reference']),\n            models.Index(fields=['user', 'status']),\n            models.Index(fields=['method', 'status']),\n        ]\n    \n    def __str__(self):\n        return f\"Payment {self.payment_reference} - {self.amount} {self.currency}\"\n    \n    def save(self, *args, **kwargs):\n        # Generate payment reference if not exists\n        if not self.payment_reference:\n            self.payment_reference = self.generate_payment_reference()\n        \n        # Update processed timestamp\n        if self.status in ['success', 'failed', 'cancelled'] and not self.processed_at:\n            from django.utils import timezone\n            self.processed_at = timezone.now()\n        \n        super().save(*args, **kwargs)\n    \n    def generate_payment_reference(self):\n        \"\"\"Generate unique payment reference\"\"\"\n        return f\"PAY-{uuid.uuid4().hex[:12].upper()}\"\n    \n    @property\n    def is_successful(self):\n        \"\"\"Check if payment was successful\"\"\"\n        return self.status == 'success'\n    \n    @property\n    def is_pending(self):\n        \"\"\"Check if payment is pending\"\"\"\n        return self.status in ['pending', 'processing']\n    \n    @property\n    def can_be_refunded(self):\n        \"\"\"Check if payment can be refunded\"\"\"\n        return self.status == 'success'\n\nclass PaymentLog(models.Model):\n    \"\"\"\n    Log model for tracking payment events and API calls\n    \"\"\"\n    payment = models.ForeignKey(Payment, on_delete=models.CASCADE, related_name='logs')\n    event_type = models.CharField(max_length=50)  # e.g., 'api_call', 'webhook', 'status_change'\n    message = models.TextField()\n    data = models.JSONField(blank=True, null=True)\n    \n    created_at = models.DateTimeField(auto_now_add=True)\n    \n    class Meta:\n        db_table = 'payment_logs'\n        verbose_name = 'Payment Log'\n        verbose_name_plural = 'Payment Logs'\n        ordering = ['-created_at']\n    \n    def __str__(self):\n        return f\"{self.payment.payment_reference} - {self.event_type}\"\n\nclass RefundRequest(models.Model):\n    \"\"\"\n    Model for tracking refund requests\n    \"\"\"\n    STATUS_CHOICES = [\n        ('pending', 'Pending'),\n        ('approved', 'Approved'),\n        ('rejected', 'Rejected'),\n        ('processing', 'Processing'),\n        ('completed', 'Completed'),\n        ('failed', 'Failed'),\n    ]\n    \n    payment = models.ForeignKey(Payment, on_delete=models.CASCADE, related_name='refund_requests')\n    requested_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='refund_requests')\n    \n    amount = models.DecimalField(max_digits=10, decimal_places=2)\n    reason = models.TextField()\n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')\n    \n    # Admin review\n    reviewed_by = models.ForeignKey(User, on_delete=models.SET_NULL, null=True, blank=True, related_name='reviewed_refunds')\n    admin_notes = models.TextField(blank=True)\n    \n    # Refund processing\n    refund_reference = models.CharField(max_length=100, blank=True)\n    processed_amount = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)\n    \n    # Timestamps\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    processed_at = models.DateTimeField(null=True, blank=True)\n    \n    class Meta:\n        db_table = 'refund_requests'\n        verbose_name = 'Refund Request'\n        verbose_name_plural = 'Refund Requests'\n        ordering = ['-created_at']\n    \n    def __str__(self):\n        return f\"Refund {self.payment.payment_reference} - {self.amount}\"\n    \n    @property\n    def can_be_approved(self):\n        \"\"\"Check if refund can be approved\"\"\"\n        return self.status == 'pending' and self.payment.can_be_refunded\n    \n    def approve(self, admin_user, notes=''):\n        \"\"\"Approve the refund request\"\"\"\n        if not self.can_be_approved:\n            raise ValueError(\"Refund cannot be approved\")\n        \n        self.status = 'approved'\n        self.reviewed_by = admin_user\n        self.admin_notes = notes\n        self.save()\n    \n    def reject(self, admin_user, notes=''):\n        \"\"\"Reject the refund request\"\"\"\n        if self.status != 'pending':\n            raise ValueError(\"Only pending refunds can be rejected\")\n        \n        self.status = 'rejected'\n        self.reviewed_by = admin_user\n        self.admin_notes = notes\n        self.save()\n","size_bytes":6706},"apps/payments/serializers.py":{"content":"from rest_framework import serializers\nfrom decimal import Decimal\nfrom .models import Payment, PaymentLog, RefundRequest\n\nclass PaymentSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Payment model\n    \"\"\"\n    user = serializers.StringRelatedField(read_only=True)\n    is_successful = serializers.ReadOnlyField()\n    is_pending = serializers.ReadOnlyField()\n    can_be_refunded = serializers.ReadOnlyField()\n    \n    class Meta:\n        model = Payment\n        fields = [\n            'id', 'payment_reference', 'external_reference', 'amount', 'currency',\n            'method', 'status', 'user', 'mobile_money_phone', 'mobile_money_provider',\n            'card_last_four', 'card_brand', 'failure_reason', 'is_successful',\n            'is_pending', 'can_be_refunded', 'created_at', 'updated_at', 'processed_at'\n        ]\n        read_only_fields = [\n            'id', 'payment_reference', 'external_reference', 'user', 'status',\n            'mobile_money_provider', 'card_last_four', 'card_brand', 'failure_reason',\n            'is_successful', 'is_pending', 'can_be_refunded', 'created_at',\n            'updated_at', 'processed_at'\n        ]\n\nclass PaymentLogSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Payment Log model\n    \"\"\"\n    class Meta:\n        model = PaymentLog\n        fields = ['id', 'event_type', 'message', 'data', 'created_at']\n        read_only_fields = ['id', 'created_at']\n\nclass RefundRequestSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Refund Request model\n    \"\"\"\n    payment = PaymentSerializer(read_only=True)\n    requested_by = serializers.StringRelatedField(read_only=True)\n    reviewed_by = serializers.StringRelatedField(read_only=True)\n    can_be_approved = serializers.ReadOnlyField()\n    \n    class Meta:\n        model = RefundRequest\n        fields = [\n            'id', 'payment', 'requested_by', 'amount', 'reason', 'status',\n            'reviewed_by', 'admin_notes', 'refund_reference', 'processed_amount',\n            'can_be_approved', 'created_at', 'updated_at', 'processed_at'\n        ]\n        read_only_fields = [\n            'id', 'payment', 'requested_by', 'status', 'reviewed_by',\n            'admin_notes', 'refund_reference', 'processed_amount',\n            'can_be_approved', 'created_at', 'updated_at', 'processed_at'\n        ]\n\nclass RefundRequestCreateSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for creating refund requests\n    \"\"\"\n    class Meta:\n        model = RefundRequest\n        fields = ['amount', 'reason']\n    \n    def validate_amount(self, value):\n        if value <= Decimal('0.00'):\n            raise serializers.ValidationError(\"Refund amount must be greater than 0\")\n        return value\n    \n    def validate(self, attrs):\n        # Get payment from context\n        payment = self.context.get('payment')\n        if not payment:\n            raise serializers.ValidationError(\"Payment context is required\")\n        \n        amount = attrs.get('amount')\n        \n        # Check if payment can be refunded\n        if not payment.can_be_refunded:\n            raise serializers.ValidationError(\"Payment cannot be refunded\")\n        \n        # Check if refund amount is valid\n        if amount > payment.amount:\n            raise serializers.ValidationError(\"Refund amount cannot exceed payment amount\")\n        \n        # Check for existing pending refund requests\n        existing_refunds = RefundRequest.objects.filter(\n            payment=payment,\n            status__in=['pending', 'approved', 'processing']\n        )\n        \n        if existing_refunds.exists():\n            raise serializers.ValidationError(\"A refund request is already pending for this payment\")\n        \n        return attrs\n\nclass RefundApprovalSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for approving/rejecting refund requests\n    \"\"\"\n    action = serializers.ChoiceField(choices=['approve', 'reject'])\n    admin_notes = serializers.CharField(required=False, allow_blank=True)\n\nclass PaymentStatsSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for payment statistics\n    \"\"\"\n    total_payments = serializers.IntegerField()\n    total_amount = serializers.DecimalField(max_digits=15, decimal_places=2)\n    successful_payments = serializers.IntegerField()\n    successful_amount = serializers.DecimalField(max_digits=15, decimal_places=2)\n    failed_payments = serializers.IntegerField()\n    pending_payments = serializers.IntegerField()\n    refund_requests = serializers.IntegerField()\n    payments_by_method = serializers.DictField()\n    monthly_revenue = serializers.ListField()\n\nclass PaymentWebhookSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for payment webhook data\n    \"\"\"\n    payment_reference = serializers.CharField()\n    external_reference = serializers.CharField(required=False)\n    status = serializers.ChoiceField(choices=['success', 'failed', 'cancelled'])\n    amount = serializers.DecimalField(max_digits=10, decimal_places=2, required=False)\n    provider_data = serializers.JSONField(required=False)\n    failure_reason = serializers.CharField(required=False, allow_blank=True)\n","size_bytes":5156},"apps/payments/urls.py":{"content":"from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\n\nfrom .views import PaymentViewSet, RefundRequestViewSet, PaymentWebhookView\n\nrouter = DefaultRouter()\nrouter.register(r'payments', PaymentViewSet, basename='payment')\nrouter.register(r'refunds', RefundRequestViewSet, basename='refund')\nrouter.register(r'webhooks', PaymentWebhookView, basename='webhook')\n\nurlpatterns = [\n    path('', include(router.urls)),\n]\n","size_bytes":448},"apps/payments/views.py":{"content":"from rest_framework import viewsets, status, permissions\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom django.shortcuts import get_object_or_404\nfrom django.db.models import Sum, Count, Q\nfrom django.utils import timezone\nfrom drf_spectacular.utils import extend_schema, OpenApiResponse\nfrom datetime import timedelta\n\nfrom .models import Payment, RefundRequest, PaymentLog\nfrom .serializers import (\n    PaymentSerializer,\n    RefundRequestSerializer,\n    RefundRequestCreateSerializer,\n    RefundApprovalSerializer,\n    PaymentStatsSerializer,\n    PaymentWebhookSerializer\n)\nfrom .services import PaymentService\n\nclass PaymentPermission(permissions.BasePermission):\n    \"\"\"\n    Custom permission for payments:\n    - Users can view their own payments\n    - Admins can view all payments\n    \"\"\"\n    \n    def has_permission(self, request, view):\n        return request.user.is_authenticated\n    \n    def has_object_permission(self, request, view, obj):\n        if request.user.role == 'admin':\n            return True\n        \n        return obj.user == request.user\n\nclass PaymentViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    ViewSet for viewing payments\n    \"\"\"\n    serializer_class = PaymentSerializer\n    permission_classes = [PaymentPermission]\n    \n    def get_queryset(self):\n        user = self.request.user\n        \n        if user.role == 'admin':\n            return Payment.objects.all().select_related('user', 'purchase__ticket__event')\n        else:\n            return Payment.objects.filter(user=user).select_related('purchase__ticket__event')\n    \n    @extend_schema(\n        summary=\"List Payments\",\n        description=\"Get list of payments for the authenticated user\",\n        responses={200: PaymentSerializer(many=True)}\n    )\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Get Payment Details\",\n        description=\"Get detailed information about a specific payment\",\n        responses={200: PaymentSerializer}\n    )\n    def retrieve(self, request, *args, **kwargs):\n        return super().retrieve(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Retry Payment\",\n        description=\"Retry a failed payment\",\n        responses={200: PaymentSerializer}\n    )\n    @action(detail=True, methods=['post'])\n    def retry(self, request, pk=None):\n        \"\"\"Retry a failed payment\"\"\"\n        payment = self.get_object()\n        \n        if payment.status not in ['failed', 'cancelled']:\n            return Response({\n                'error': 'Only failed or cancelled payments can be retried'\n            }, status=status.HTTP_400_BAD_REQUEST)\n        \n        # Check if purchase is still valid\n        if payment.purchase and payment.purchase.status == 'cancelled':\n            return Response({\n                'error': 'Cannot retry payment for cancelled purchase'\n            }, status=status.HTTP_400_BAD_REQUEST)\n        \n        try:\n            payment_service = PaymentService()\n            result = payment_service.retry_payment(payment)\n            \n            if result['success']:\n                return Response({\n                    'message': 'Payment retry initiated',\n                    'payment': PaymentSerializer(payment, context={'request': request}).data\n                })\n            else:\n                return Response({\n                    'error': 'Payment retry failed',\n                    'details': result.get('error', 'Unknown error')\n                }, status=status.HTTP_400_BAD_REQUEST)\n        \n        except Exception as e:\n            return Response({\n                'error': 'Payment retry failed',\n                'details': str(e)\n            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n    \n    @extend_schema(\n        summary=\"Get Payment Statistics\",\n        description=\"Get payment statistics (admin only)\",\n        responses={200: PaymentStatsSerializer}\n    )\n    @action(detail=False, methods=['get'], permission_classes=[permissions.IsAuthenticated])\n    def stats(self, request):\n        \"\"\"Get payment statistics\"\"\"\n        if request.user.role != 'admin':\n            return Response({\n                'error': 'Permission denied'\n            }, status=status.HTTP_403_FORBIDDEN)\n        \n        # Calculate statistics\n        total_payments = Payment.objects.count()\n        total_amount = Payment.objects.aggregate(Sum('amount'))['amount__sum'] or 0\n        \n        successful_payments = Payment.objects.filter(status='success').count()\n        successful_amount = Payment.objects.filter(status='success').aggregate(Sum('amount'))['amount__sum'] or 0\n        \n        failed_payments = Payment.objects.filter(status='failed').count()\n        pending_payments = Payment.objects.filter(status__in=['pending', 'processing']).count()\n        refund_requests_count = RefundRequest.objects.count()\n        \n        # Payments by method\n        payments_by_method = dict(\n            Payment.objects.values('method').annotate(count=Count('id')).values_list('method', 'count')\n        )\n        \n        # Monthly revenue for the last 12 months\n        monthly_revenue = []\n        for i in range(12):\n            month_start = timezone.now().replace(day=1, hour=0, minute=0, second=0, microsecond=0) - timedelta(days=30*i)\n            month_end = month_start.replace(day=28) + timedelta(days=4)\n            month_end = month_end - timedelta(days=month_end.day)\n            \n            revenue = Payment.objects.filter(\n                status='success',\n                created_at__range=[month_start, month_end]\n            ).aggregate(Sum('amount'))['amount__sum'] or 0\n            \n            monthly_revenue.append({\n                'month': month_start.strftime('%Y-%m'),\n                'revenue': float(revenue)\n            })\n        \n        stats = {\n            'total_payments': total_payments,\n            'total_amount': total_amount,\n            'successful_payments': successful_payments,\n            'successful_amount': successful_amount,\n            'failed_payments': failed_payments,\n            'pending_payments': pending_payments,\n            'refund_requests': refund_requests_count,\n            'payments_by_method': payments_by_method,\n            'monthly_revenue': monthly_revenue\n        }\n        \n        serializer = PaymentStatsSerializer(stats)\n        return Response(serializer.data)\n\nclass RefundRequestViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    ViewSet for managing refund requests\n    \"\"\"\n    serializer_class = RefundRequestSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_queryset(self):\n        user = self.request.user\n        \n        if user.role == 'admin':\n            return RefundRequest.objects.all().select_related('payment', 'requested_by', 'reviewed_by')\n        else:\n            return RefundRequest.objects.filter(requested_by=user).select_related('payment', 'reviewed_by')\n    \n    def get_serializer_class(self):\n        if self.action == 'create':\n            return RefundRequestCreateSerializer\n        return RefundRequestSerializer\n    \n    @extend_schema(\n        summary=\"Create Refund Request\",\n        description=\"Create a new refund request for a payment\",\n        request=RefundRequestCreateSerializer,\n        responses={201: RefundRequestSerializer}\n    )\n    def create(self, request, *args, **kwargs):\n        # Get payment from URL or request data\n        payment_id = request.data.get('payment_id')\n        if not payment_id:\n            return Response({\n                'error': 'payment_id is required'\n            }, status=status.HTTP_400_BAD_REQUEST)\n        \n        payment = get_object_or_404(Payment, id=payment_id, user=request.user)\n        \n        serializer = self.get_serializer(\n            data=request.data,\n            context={'request': request, 'payment': payment}\n        )\n        \n        if serializer.is_valid():\n            refund_request = serializer.save(\n                payment=payment,\n                requested_by=request.user\n            )\n            \n            # Send notification to admins\n            from apps.notifications.services import NotificationService\n            notification_service = NotificationService()\n            notification_service.send_refund_request_notification(refund_request)\n            \n            return Response(\n                RefundRequestSerializer(refund_request, context={'request': request}).data,\n                status=status.HTTP_201_CREATED\n            )\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    \n    @extend_schema(\n        summary=\"Review Refund Request\",\n        description=\"Approve or reject a refund request (admin only)\",\n        request=RefundApprovalSerializer,\n        responses={200: RefundRequestSerializer}\n    )\n    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])\n    def review(self, request, pk=None):\n        \"\"\"Review a refund request (admin only)\"\"\"\n        if request.user.role != 'admin':\n            return Response({\n                'error': 'Permission denied'\n            }, status=status.HTTP_403_FORBIDDEN)\n        \n        refund_request = self.get_object()\n        serializer = RefundApprovalSerializer(data=request.data)\n        \n        if serializer.is_valid():\n            action = serializer.validated_data['action']\n            admin_notes = serializer.validated_data.get('admin_notes', '')\n            \n            try:\n                if action == 'approve':\n                    refund_request.approve(request.user, admin_notes)\n                    \n                    # Process the refund\n                    payment_service = PaymentService()\n                    refund_result = payment_service.process_refund(refund_request)\n                    \n                    if refund_result['success']:\n                        refund_request.status = 'completed'\n                        refund_request.refund_reference = refund_result.get('refund_reference', '')\n                        refund_request.processed_amount = refund_request.amount\n                        refund_request.processed_at = timezone.now()\n                        refund_request.save()\n                    else:\n                        refund_request.status = 'failed'\n                        refund_request.admin_notes += f\"\\nRefund processing failed: {refund_result.get('error', 'Unknown error')}\"\n                        refund_request.save()\n                \n                elif action == 'reject':\n                    refund_request.reject(request.user, admin_notes)\n                \n                # Send notification to user\n                from apps.notifications.services import NotificationService\n                notification_service = NotificationService()\n                notification_service.send_refund_status_notification(refund_request)\n                \n                return Response(\n                    RefundRequestSerializer(refund_request, context={'request': request}).data\n                )\n            \n            except ValueError as e:\n                return Response({\n                    'error': str(e)\n                }, status=status.HTTP_400_BAD_REQUEST)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\nclass PaymentWebhookView(viewsets.GenericViewSet):\n    \"\"\"\n    ViewSet for handling payment webhooks\n    \"\"\"\n    permission_classes = []  # Webhook endpoints don't require authentication\n    serializer_class = PaymentWebhookSerializer\n    \n    @extend_schema(\n        summary=\"Payment Webhook\",\n        description=\"Handle payment status updates from payment providers\",\n        request=PaymentWebhookSerializer,\n        responses={200: OpenApiResponse(description=\"Webhook processed successfully\")}\n    )\n    @action(detail=False, methods=['post'])\n    def mobile_money(self, request):\n        \"\"\"Handle mobile money payment webhooks\"\"\"\n        serializer = PaymentWebhookSerializer(data=request.data)\n        \n        if serializer.is_valid():\n            try:\n                payment_service = PaymentService()\n                result = payment_service.handle_webhook(\n                    'mobile_money',\n                    serializer.validated_data\n                )\n                \n                if result['success']:\n                    return Response({\n                        'status': 'success',\n                        'message': 'Webhook processed successfully'\n                    })\n                else:\n                    return Response({\n                        'status': 'error',\n                        'message': result.get('error', 'Webhook processing failed')\n                    }, status=status.HTTP_400_BAD_REQUEST)\n            \n            except Exception as e:\n                return Response({\n                    'status': 'error',\n                    'message': str(e)\n                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n    \n    @extend_schema(\n        summary=\"Card Payment Webhook\",\n        description=\"Handle card payment status updates from payment providers\",\n        request=PaymentWebhookSerializer,\n        responses={200: OpenApiResponse(description=\"Webhook processed successfully\")}\n    )\n    @action(detail=False, methods=['post'])\n    def card(self, request):\n        \"\"\"Handle card payment webhooks\"\"\"\n        serializer = PaymentWebhookSerializer(data=request.data)\n        \n        if serializer.is_valid():\n            try:\n                payment_service = PaymentService()\n                result = payment_service.handle_webhook(\n                    'card',\n                    serializer.validated_data\n                )\n                \n                if result['success']:\n                    return Response({\n                        'status': 'success',\n                        'message': 'Webhook processed successfully'\n                    })\n                else:\n                    return Response({\n                        'status': 'error',\n                        'message': result.get('error', 'Webhook processing failed')\n                    }, status=status.HTTP_400_BAD_REQUEST)\n            \n            except Exception as e:\n                return Response({\n                    'status': 'error',\n                    'message': str(e)\n                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n","size_bytes":14688},"apps/tickets/__init__.py":{"content":"","size_bytes":0},"apps/tickets/models.py":{"content":"from django.db import models\nfrom django.contrib.auth import get_user_model\nfrom django.core.validators import MinValueValidator\nfrom decimal import Decimal\nimport qrcode\nfrom io import BytesIO\nfrom django.core.files.base import ContentFile\nimport uuid\n\nUser = get_user_model()\n\nclass Ticket(models.Model):\n    \"\"\"\n    Ticket type model for events\n    \"\"\"\n    name = models.CharField(max_length=100)\n    description = models.TextField(blank=True)\n    price = models.DecimalField(max_digits=10, decimal_places=2, validators=[MinValueValidator(Decimal('0.00'))])\n    quantity_available = models.PositiveIntegerField(validators=[MinValueValidator(1)])\n    quantity_sold = models.PositiveIntegerField(default=0)\n    \n    # Relations\n    event = models.ForeignKey('events.Event', on_delete=models.CASCADE, related_name='tickets')\n    \n    # Settings\n    is_active = models.BooleanField(default=True)\n    sale_start_datetime = models.DateTimeField(null=True, blank=True)\n    sale_end_datetime = models.DateTimeField(null=True, blank=True)\n    \n    # Timestamps\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    class Meta:\n        db_table = 'tickets'\n        verbose_name = 'Ticket'\n        verbose_name_plural = 'Tickets'\n        ordering = ['price']\n        indexes = [\n            models.Index(fields=['event', 'is_active']),\n            models.Index(fields=['price']),\n        ]\n    \n    def __str__(self):\n        return f\"{self.name} - {self.event.title}\"\n    \n    @property\n    def quantity_remaining(self):\n        \"\"\"Get remaining quantity\"\"\"\n        return max(0, self.quantity_available - self.quantity_sold)\n    \n    @property\n    def is_sold_out(self):\n        \"\"\"Check if ticket is sold out\"\"\"\n        return self.quantity_remaining == 0\n    \n    @property\n    def is_available_for_sale(self):\n        \"\"\"Check if ticket is available for sale\"\"\"\n        from django.utils import timezone\n        now = timezone.now()\n        \n        if not self.is_active or self.is_sold_out:\n            return False\n        \n        if self.sale_start_datetime and now < self.sale_start_datetime:\n            return False\n        \n        if self.sale_end_datetime and now > self.sale_end_datetime:\n            return False\n        \n        return True\n    \n    def can_purchase(self, quantity):\n        \"\"\"Check if a specific quantity can be purchased\"\"\"\n        return (\n            self.is_available_for_sale and \n            quantity <= self.quantity_remaining and\n            quantity > 0\n        )\n\nclass Purchase(models.Model):\n    \"\"\"\n    Ticket purchase model\n    \"\"\"\n    STATUS_CHOICES = [\n        ('pending', 'Pending'),\n        ('paid', 'Paid'),\n        ('cancelled', 'Cancelled'),\n        ('refunded', 'Refunded'),\n    ]\n    \n    # Purchase details\n    ticket = models.ForeignKey(Ticket, on_delete=models.CASCADE, related_name='purchases')\n    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='purchases')\n    quantity = models.PositiveIntegerField(validators=[MinValueValidator(1)])\n    unit_price = models.DecimalField(max_digits=10, decimal_places=2)\n    total_amount = models.DecimalField(max_digits=10, decimal_places=2)\n    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='pending')\n    \n    # QR Code\n    qr_code = models.ImageField(upload_to='tickets/qrcodes/', blank=True, null=True)\n    qr_code_data = models.TextField(blank=True)  # Store QR code data for validation\n    \n    # Purchase metadata\n    purchase_reference = models.CharField(max_length=50, unique=True, editable=False)\n    payment_method = models.CharField(max_length=50, blank=True)\n    payment_reference = models.CharField(max_length=100, blank=True)\n    \n    # Timestamps\n    created_at = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    paid_at = models.DateTimeField(null=True, blank=True)\n    \n    class Meta:\n        db_table = 'purchases'\n        verbose_name = 'Purchase'\n        verbose_name_plural = 'Purchases'\n        ordering = ['-created_at']\n        indexes = [\n            models.Index(fields=['user', 'status']),\n            models.Index(fields=['ticket', 'status']),\n            models.Index(fields=['purchase_reference']),\n        ]\n    \n    def __str__(self):\n        return f\"Purchase {self.purchase_reference} - {self.user.full_name}\"\n    \n    def save(self, *args, **kwargs):\n        # Generate purchase reference if not exists\n        if not self.purchase_reference:\n            self.purchase_reference = self.generate_purchase_reference()\n        \n        # Calculate total amount\n        self.total_amount = self.unit_price * self.quantity\n        \n        # Generate QR code when status changes to paid\n        if self.status == 'paid' and not self.qr_code:\n            self.generate_qr_code()\n        \n        # Update paid timestamp\n        if self.status == 'paid' and not self.paid_at:\n            from django.utils import timezone\n            self.paid_at = timezone.now()\n        \n        super().save(*args, **kwargs)\n        \n        # Update ticket quantity sold\n        if self.pk:  # Only if saved to database\n            self.update_ticket_quantity()\n    \n    def generate_purchase_reference(self):\n        \"\"\"Generate unique purchase reference\"\"\"\n        return f\"EVT-{uuid.uuid4().hex[:8].upper()}\"\n    \n    def generate_qr_code(self):\n        \"\"\"Generate QR code for the purchase\"\"\"\n        # QR code data includes purchase details\n        qr_data = {\n            'purchase_id': str(self.id),\n            'reference': self.purchase_reference,\n            'event_id': str(self.ticket.event.id),\n            'event_title': self.ticket.event.title,\n            'ticket_name': self.ticket.name,\n            'quantity': self.quantity,\n            'user_email': self.user.email,\n            'purchase_date': self.created_at.isoformat() if self.created_at else None\n        }\n        \n        import json\n        self.qr_code_data = json.dumps(qr_data)\n        \n        # Generate QR code image\n        qr = qrcode.QRCode(\n            version=1,\n            error_correction=qrcode.constants.ERROR_CORRECT_L,\n            box_size=10,\n            border=4,\n        )\n        qr.add_data(self.qr_code_data)\n        qr.make(fit=True)\n        \n        img = qr.make_image(fill_color=\"black\", back_color=\"white\")\n        \n        # Save to field\n        buffer = BytesIO()\n        img.save(buffer, format='PNG')\n        buffer.seek(0)\n        \n        filename = f'qr_{self.purchase_reference}.png'\n        self.qr_code.save(filename, ContentFile(buffer.read()), save=False)\n        buffer.close()\n    \n    def update_ticket_quantity(self):\n        \"\"\"Update ticket quantity sold\"\"\"\n        paid_purchases = Purchase.objects.filter(\n            ticket=self.ticket,\n            status='paid'\n        ).aggregate(\n            total_sold=models.Sum('quantity')\n        )\n        \n        self.ticket.quantity_sold = paid_purchases['total_sold'] or 0\n        self.ticket.save(update_fields=['quantity_sold'])\n    \n    @property\n    def can_be_cancelled(self):\n        \"\"\"Check if purchase can be cancelled\"\"\"\n        from django.utils import timezone\n        \n        # Can only cancel pending or paid purchases\n        if self.status not in ['pending', 'paid']:\n            return False\n        \n        # Cannot cancel if event has started\n        if self.ticket.event.start_datetime <= timezone.now():\n            return False\n        \n        return True\n    \n    def cancel(self):\n        \"\"\"Cancel the purchase\"\"\"\n        if not self.can_be_cancelled:\n            raise ValueError(\"Purchase cannot be cancelled\")\n        \n        self.status = 'cancelled'\n        self.save()\n    \n    @property\n    def attendee_names(self):\n        \"\"\"Get list of attendee names for this purchase\"\"\"\n        return [attendee.full_name for attendee in self.attendees.all()]\n\nclass Attendee(models.Model):\n    \"\"\"\n    Individual attendee for a purchase (useful for group bookings)\n    \"\"\"\n    purchase = models.ForeignKey(Purchase, on_delete=models.CASCADE, related_name='attendees')\n    first_name = models.CharField(max_length=50)\n    last_name = models.CharField(max_length=50)\n    email = models.EmailField(blank=True)\n    phone = models.CharField(max_length=20, blank=True)\n    \n    # Check-in tracking\n    checked_in = models.BooleanField(default=False)\n    check_in_datetime = models.DateTimeField(null=True, blank=True)\n    \n    created_at = models.DateTimeField(auto_now_add=True)\n    \n    class Meta:\n        db_table = 'attendees'\n        verbose_name = 'Attendee'\n        verbose_name_plural = 'Attendees'\n    \n    def __str__(self):\n        return f\"{self.first_name} {self.last_name}\"\n    \n    @property\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n    \n    def check_in(self):\n        \"\"\"Check in the attendee\"\"\"\n        if not self.checked_in:\n            from django.utils import timezone\n            self.checked_in = True\n            self.check_in_datetime = timezone.now()\n            self.save()\n\nclass TicketValidation(models.Model):\n    \"\"\"\n    Model to track ticket validations at event entry\n    \"\"\"\n    purchase = models.ForeignKey(Purchase, on_delete=models.CASCADE, related_name='validations')\n    validated_by = models.ForeignKey(User, on_delete=models.CASCADE, related_name='ticket_validations')\n    validation_datetime = models.DateTimeField(auto_now_add=True)\n    location = models.CharField(max_length=100, blank=True)  # Entry gate/location\n    notes = models.TextField(blank=True)\n    \n    class Meta:\n        db_table = 'ticket_validations'\n        verbose_name = 'Ticket Validation'\n        verbose_name_plural = 'Ticket Validations'\n    \n    def __str__(self):\n        return f\"Validation for {self.purchase.purchase_reference}\"\n","size_bytes":9860},"apps/tickets/serializers.py":{"content":"from rest_framework import serializers\nfrom decimal import Decimal\nfrom .models import Ticket, Purchase, Attendee, TicketValidation\nfrom apps.events.serializers import EventListSerializer\nfrom apps.users.serializers import UserSerializer\n\nclass AttendeeSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Attendee model\n    \"\"\"\n    class Meta:\n        model = Attendee\n        fields = ['id', 'first_name', 'last_name', 'email', 'phone', 'checked_in', 'check_in_datetime']\n        read_only_fields = ['id', 'checked_in', 'check_in_datetime']\n\nclass TicketSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Ticket model\n    \"\"\"\n    event = EventListSerializer(read_only=True)\n    quantity_remaining = serializers.ReadOnlyField()\n    is_sold_out = serializers.ReadOnlyField()\n    is_available_for_sale = serializers.ReadOnlyField()\n    \n    class Meta:\n        model = Ticket\n        fields = [\n            'id', 'name', 'description', 'price', 'quantity_available',\n            'quantity_sold', 'quantity_remaining', 'is_sold_out',\n            'is_available_for_sale', 'event', 'sale_start_datetime',\n            'sale_end_datetime', 'created_at', 'updated_at'\n        ]\n        read_only_fields = [\n            'id', 'quantity_sold', 'quantity_remaining', 'is_sold_out',\n            'is_available_for_sale', 'created_at', 'updated_at'\n        ]\n\nclass TicketCreateUpdateSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for creating and updating tickets\n    \"\"\"\n    class Meta:\n        model = Ticket\n        fields = [\n            'name', 'description', 'price', 'quantity_available',\n            'sale_start_datetime', 'sale_end_datetime'\n        ]\n    \n    def validate_price(self, value):\n        if value < Decimal('0.00'):\n            raise serializers.ValidationError(\"Price cannot be negative\")\n        return value\n    \n    def validate_quantity_available(self, value):\n        if value < 1:\n            raise serializers.ValidationError(\"Quantity available must be at least 1\")\n        \n        # For updates, ensure new quantity >= already sold\n        if self.instance and value < self.instance.quantity_sold:\n            raise serializers.ValidationError(\n                f\"Cannot reduce quantity below already sold tickets ({self.instance.quantity_sold})\"\n            )\n        \n        return value\n    \n    def validate(self, attrs):\n        \"\"\"Validate sale datetime range\"\"\"\n        sale_start = attrs.get('sale_start_datetime')\n        sale_end = attrs.get('sale_end_datetime')\n        \n        if sale_start and sale_end:\n            if sale_end <= sale_start:\n                raise serializers.ValidationError({\n                    'sale_end_datetime': \"Sale end datetime must be after sale start datetime\"\n                })\n        \n        return attrs\n\nclass PurchaseSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Purchase model\n    \"\"\"\n    ticket = TicketSerializer(read_only=True)\n    user = UserSerializer(read_only=True)\n    attendees = AttendeeSerializer(many=True, read_only=True)\n    can_be_cancelled = serializers.ReadOnlyField()\n    qr_code_url = serializers.SerializerMethodField()\n    \n    class Meta:\n        model = Purchase\n        fields = [\n            'id', 'ticket', 'user', 'quantity', 'unit_price', 'total_amount',\n            'status', 'purchase_reference', 'payment_method', 'payment_reference',\n            'qr_code_url', 'qr_code_data', 'attendees', 'can_be_cancelled',\n            'created_at', 'updated_at', 'paid_at'\n        ]\n        read_only_fields = [\n            'id', 'ticket', 'user', 'unit_price', 'total_amount', 'status',\n            'purchase_reference', 'payment_reference', 'qr_code_data',\n            'can_be_cancelled', 'created_at', 'updated_at', 'paid_at'\n        ]\n    \n    def get_qr_code_url(self, obj):\n        \"\"\"Get QR code URL\"\"\"\n        if obj.qr_code:\n            request = self.context.get('request')\n            if request:\n                return request.build_absolute_uri(obj.qr_code.url)\n        return None\n\nclass TicketPurchaseSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for purchasing tickets\n    \"\"\"\n    quantity = serializers.IntegerField(min_value=1)\n    payment_method = serializers.ChoiceField(choices=['mobile_money', 'card'])\n    \n    # Mobile Money fields\n    phone = serializers.CharField(max_length=20, required=False)\n    \n    # Card payment fields\n    card_number = serializers.CharField(max_length=20, required=False)\n    card_expiry = serializers.CharField(max_length=7, required=False)  # MM/YYYY\n    card_cvv = serializers.CharField(max_length=4, required=False)\n    card_holder_name = serializers.CharField(max_length=100, required=False)\n    \n    # Attendee information (optional for group bookings)\n    attendees = AttendeeSerializer(many=True, required=False)\n    \n    def validate(self, attrs):\n        \"\"\"Validate payment method specific fields\"\"\"\n        payment_method = attrs.get('payment_method')\n        \n        if payment_method == 'mobile_money':\n            if not attrs.get('phone'):\n                raise serializers.ValidationError({\n                    'phone': 'Phone number is required for mobile money payment'\n                })\n        \n        elif payment_method == 'card':\n            required_fields = ['card_number', 'card_expiry', 'card_cvv', 'card_holder_name']\n            for field in required_fields:\n                if not attrs.get(field):\n                    raise serializers.ValidationError({\n                        field: f'{field.replace(\"_\", \" \").title()} is required for card payment'\n                    })\n        \n        # Validate attendee count matches quantity\n        attendees = attrs.get('attendees', [])\n        quantity = attrs.get('quantity', 1)\n        \n        if attendees and len(attendees) != quantity:\n            raise serializers.ValidationError({\n                'attendees': f'Number of attendees ({len(attendees)}) must match quantity ({quantity})'\n            })\n        \n        return attrs\n    \n    def validate_card_expiry(self, value):\n        \"\"\"Validate card expiry format\"\"\"\n        if value:\n            try:\n                month, year = value.split('/')\n                if not (1 <= int(month) <= 12):\n                    raise ValueError(\"Invalid month\")\n                if len(year) != 4:\n                    raise ValueError(\"Year must be 4 digits\")\n            except (ValueError, IndexError):\n                raise serializers.ValidationError(\"Invalid expiry format. Use MM/YYYY\")\n        return value\n\nclass TicketValidationSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for Ticket Validation\n    \"\"\"\n    purchase = PurchaseSerializer(read_only=True)\n    validated_by = UserSerializer(read_only=True)\n    \n    class Meta:\n        model = TicketValidation\n        fields = ['id', 'purchase', 'validated_by', 'validation_datetime', 'location', 'notes']\n        read_only_fields = ['id', 'purchase', 'validated_by', 'validation_datetime']\n\nclass QRCodeValidationSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for QR code validation\n    \"\"\"\n    qr_code_data = serializers.CharField()\n    location = serializers.CharField(max_length=100, required=False)\n    notes = serializers.CharField(required=False)\n\nclass PurchaseCreateSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for creating purchases (internal use)\n    \"\"\"\n    class Meta:\n        model = Purchase\n        fields = [\n            'ticket', 'user', 'quantity', 'unit_price', 'payment_method'\n        ]\n    \n    def create(self, validated_data):\n        # Calculate total amount\n        validated_data['total_amount'] = validated_data['unit_price'] * validated_data['quantity']\n        return super().create(validated_data)\n\nclass PurchaseStatsSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for purchase statistics\n    \"\"\"\n    total_purchases = serializers.IntegerField()\n    total_revenue = serializers.DecimalField(max_digits=10, decimal_places=2)\n    total_tickets = serializers.IntegerField()\n    purchases_by_status = serializers.DictField()\n    purchases_by_method = serializers.DictField()\n    monthly_sales = serializers.ListField()\n","size_bytes":8223},"apps/tickets/tests.py":{"content":"from django.test import TestCase\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom rest_framework.test import APITestCase\nfrom rest_framework import status\nfrom django.contrib.auth import get_user_model\nfrom datetime import timedelta\nfrom decimal import Decimal\n\nfrom .models import Ticket, Purchase, Attendee\nfrom apps.events.models import Event\n\nUser = get_user_model()\n\nclass TicketModelTest(TestCase):\n    \"\"\"\n    Test cases for Ticket model\n    \"\"\"\n    \n    def setUp(self):\n        self.organizer = User.objects.create_user(\n            email='organizer@example.com',\n            password='testpass123',\n            first_name='Jane',\n            last_name='Organizer',\n            role='organizer'\n        )\n        \n        self.event = Event.objects.create(\n            title='Test Event',\n            description='Test event description',\n            start_datetime=timezone.now() + timedelta(days=7),\n            end_datetime=timezone.now() + timedelta(days=7, hours=3),\n            location='Cotonou',\n            category='music',\n            max_attendees=100,\n            organizer=self.organizer\n        )\n        \n        self.ticket_data = {\n            'name': 'Regular Ticket',\n            'description': 'Regular admission ticket',\n            'price': Decimal('25.00'),\n            'quantity_available': 50,\n            'event': self.event\n        }\n    \n    def test_create_ticket(self):\n        \"\"\"Test creating a ticket\"\"\"\n        ticket = Ticket.objects.create(**self.ticket_data)\n        \n        self.assertEqual(ticket.name, self.ticket_data['name'])\n        self.assertEqual(ticket.price, self.ticket_data['price'])\n        self.assertEqual(ticket.quantity_available, self.ticket_data['quantity_available'])\n        self.assertEqual(ticket.quantity_sold, 0)\n        self.assertEqual(ticket.quantity_remaining, 50)\n        self.assertFalse(ticket.is_sold_out)\n        self.assertTrue(ticket.is_available_for_sale)\n    \n    def test_ticket_properties(self):\n        \"\"\"Test ticket properties\"\"\"\n        ticket = Ticket.objects.create(**self.ticket_data)\n        \n        # Test can_purchase\n        self.assertTrue(ticket.can_purchase(1))\n        self.assertTrue(ticket.can_purchase(25))\n        self.assertTrue(ticket.can_purchase(50))\n        self.assertFalse(ticket.can_purchase(51))  # More than available\n        self.assertFalse(ticket.can_purchase(0))   # Zero quantity\n        \n        # Test after some sales\n        ticket.quantity_sold = 30\n        ticket.save()\n        \n        self.assertEqual(ticket.quantity_remaining, 20)\n        self.assertTrue(ticket.can_purchase(20))\n        self.assertFalse(ticket.can_purchase(21))\n    \n    def test_ticket_sold_out(self):\n        \"\"\"Test ticket sold out scenario\"\"\"\n        ticket = Ticket.objects.create(**self.ticket_data)\n        ticket.quantity_sold = ticket.quantity_available\n        ticket.save()\n        \n        self.assertTrue(ticket.is_sold_out)\n        self.assertEqual(ticket.quantity_remaining, 0)\n        self.assertFalse(ticket.can_purchase(1))\n    \n    def test_ticket_string_representation(self):\n        \"\"\"Test ticket string representation\"\"\"\n        ticket = Ticket.objects.create(**self.ticket_data)\n        expected_str = f\"{ticket.name} - {ticket.event.title}\"\n        self.assertEqual(str(ticket), expected_str)\n\nclass PurchaseModelTest(TestCase):\n    \"\"\"\n    Test cases for Purchase model\n    \"\"\"\n    \n    def setUp(self):\n        self.participant = User.objects.create_user(\n            email='participant@example.com',\n            password='testpass123',\n            first_name='John',\n            last_name='Participant',\n            role='participant'\n        )\n        \n        self.organizer = User.objects.create_user(\n            email='organizer@example.com',\n            password='testpass123',\n            first_name='Jane',\n            last_name='Organizer',\n            role='organizer'\n        )\n        \n        self.event = Event.objects.create(\n            title='Test Event',\n            description='Test event description',\n            start_datetime=timezone.now() + timedelta(days=7),\n            end_datetime=timezone.now() + timedelta(days=7, hours=3),\n            location='Cotonou',\n            category='music',\n            max_attendees=100,\n            organizer=self.organizer\n        )\n        \n        self.ticket = Ticket.objects.create(\n            name='Regular Ticket',\n            price=Decimal('25.00'),\n            quantity_available=50,\n            event=self.event\n        )\n    \n    def test_create_purchase(self):\n        \"\"\"Test creating a purchase\"\"\"\n        purchase = Purchase.objects.create(\n            ticket=self.ticket,\n            user=self.participant,\n            quantity=2,\n            unit_price=self.ticket.price,\n            payment_method='mobile_money'\n        )\n        \n        self.assertEqual(purchase.quantity, 2)\n        self.assertEqual(purchase.unit_price, self.ticket.price)\n        self.assertEqual(purchase.total_amount, Decimal('50.00'))\n        self.assertEqual(purchase.status, 'pending')\n        self.assertTrue(purchase.purchase_reference.startswith('EVT-'))\n        self.assertTrue(purchase.can_be_cancelled)\n    \n    def test_purchase_reference_generation(self):\n        \"\"\"Test purchase reference generation\"\"\"\n        purchase1 = Purchase.objects.create(\n            ticket=self.ticket,\n            user=self.participant,\n            quantity=1,\n            unit_price=self.ticket.price\n        )\n        \n        purchase2 = Purchase.objects.create(\n            ticket=self.ticket,\n            user=self.participant,\n            quantity=1,\n            unit_price=self.ticket.price\n        )\n        \n        self.assertNotEqual(purchase1.purchase_reference, purchase2.purchase_reference)\n        self.assertTrue(purchase1.purchase_reference.startswith('EVT-'))\n        self.assertTrue(purchase2.purchase_reference.startswith('EVT-'))\n    \n    def test_purchase_cancellation(self):\n        \"\"\"Test purchase cancellation\"\"\"\n        purchase = Purchase.objects.create(\n            ticket=self.ticket,\n            user=self.participant,\n            quantity=1,\n            unit_price=self.ticket.price\n        )\n        \n        # Should be cancellable initially\n        self.assertTrue(purchase.can_be_cancelled)\n        \n        # Cancel the purchase\n        purchase.cancel()\n        self.assertEqual(purchase.status, 'cancelled')\n        \n        # Should not be cancellable after cancellation\n        self.assertFalse(purchase.can_be_cancelled)\n    \n    def test_qr_code_generation(self):\n        \"\"\"Test QR code generation when paid\"\"\"\n        purchase = Purchase.objects.create(\n            ticket=self.ticket,\n            user=self.participant,\n            quantity=1,\n            unit_price=self.ticket.price,\n            status='paid'\n        )\n        \n        # QR code should be generated\n        self.assertTrue(purchase.qr_code)\n        self.assertTrue(purchase.qr_code_data)\n        \n        # Parse QR code data\n        import json\n        qr_data = json.loads(purchase.qr_code_data)\n        self.assertEqual(qr_data['purchase_id'], str(purchase.id))\n        self.assertEqual(qr_data['reference'], purchase.purchase_reference)\n\nclass TicketAPITest(APITestCase):\n    \"\"\"\n    Test cases for Ticket API endpoints\n    \"\"\"\n    \n    def setUp(self):\n        self.participant = User.objects.create_user(\n            email='participant@example.com',\n            password='testpass123',\n            first_name='John',\n            last_name='Participant',\n            role='participant'\n        )\n        \n        self.organizer = User.objects.create_user(\n            email='organizer@example.com',\n            password='testpass123',\n            first_name='Jane',\n            last_name='Organizer',\n            role='organizer'\n        )\n        \n        self.event = Event.objects.create(\n            title='Test Event',\n            description='Test event description',\n            start_datetime=timezone.now() + timedelta(days=7),\n            end_datetime=timezone.now() + timedelta(days=7, hours=3),\n            location='Cotonou',\n            category='music',\n            max_attendees=100,\n            organizer=self.organizer\n        )\n        \n        self.ticket = Ticket.objects.create(\n            name='Regular Ticket',\n            price=Decimal('25.00'),\n            quantity_available=50,\n            event=self.event\n        )\n        \n        self.ticket_data = {\n            'name': 'VIP Ticket',\n            'description': 'VIP admission ticket',\n            'price': '75.00',\n            'quantity_available': 20\n        }\n        \n        self.purchase_data = {\n            'quantity': 2,\n            'payment_method': 'mobile_money',\n            'phone': '+22912345678'\n        }\n    \n    def test_list_event_tickets_unauthenticated(self):\n        \"\"\"Test listing event tickets without authentication\"\"\"\n        url = reverse('event-tickets-list', kwargs={'event_pk': self.event.id})\n        response = self.client.get(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertGreaterEqual(len(response.data), 1)\n    \n    def test_create_ticket_as_organizer(self):\n        \"\"\"Test creating ticket as event organizer\"\"\"\n        self.client.force_authenticate(user=self.organizer)\n        url = reverse('event-tickets-list', kwargs={'event_pk': self.event.id})\n        response = self.client.post(url, self.ticket_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n        self.assertEqual(response.data['name'], self.ticket_data['name'])\n    \n    def test_create_ticket_as_participant(self):\n        \"\"\"Test creating ticket as participant (should fail)\"\"\"\n        self.client.force_authenticate(user=self.participant)\n        url = reverse('event-tickets-list', kwargs={'event_pk': self.event.id})\n        response = self.client.post(url, self.ticket_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)\n    \n    def test_purchase_ticket_success(self):\n        \"\"\"Test successful ticket purchase\"\"\"\n        self.client.force_authenticate(user=self.participant)\n        url = reverse('event-tickets-purchase', kwargs={'event_pk': self.event.id, 'pk': self.ticket.id})\n        response = self.client.post(url, self.purchase_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n        self.assertIn('purchase_reference', response.data)\n        self.assertEqual(response.data['quantity'], self.purchase_data['quantity'])\n    \n    def test_purchase_ticket_insufficient_quantity(self):\n        \"\"\"Test ticket purchase with insufficient quantity\"\"\"\n        self.client.force_authenticate(user=self.participant)\n        url = reverse('event-tickets-purchase', kwargs={'event_pk': self.event.id, 'pk': self.ticket.id})\n        \n        # Try to purchase more than available\n        invalid_data = self.purchase_data.copy()\n        invalid_data['quantity'] = 100\n        \n        response = self.client.post(url, invalid_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n        self.assertIn('error', response.data)\n    \n    def test_purchase_ticket_unauthenticated(self):\n        \"\"\"Test ticket purchase without authentication\"\"\"\n        url = reverse('event-tickets-purchase', kwargs={'event_pk': self.event.id, 'pk': self.ticket.id})\n        response = self.client.post(url, self.purchase_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)\n    \n    def test_list_user_purchases(self):\n        \"\"\"Test listing user purchases\"\"\"\n        # Create a purchase first\n        purchase = Purchase.objects.create(\n            ticket=self.ticket,\n            user=self.participant,\n            quantity=1,\n            unit_price=self.ticket.price,\n            status='paid'\n        )\n        \n        self.client.force_authenticate(user=self.participant)\n        url = reverse('purchase-list')\n        response = self.client.get(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertGreaterEqual(len(response.data['results']), 1)\n    \n    def test_cancel_purchase(self):\n        \"\"\"Test cancelling a purchase\"\"\"\n        purchase = Purchase.objects.create(\n            ticket=self.ticket,\n            user=self.participant,\n            quantity=1,\n            unit_price=self.ticket.price\n        )\n        \n        self.client.force_authenticate(user=self.participant)\n        url = reverse('purchase-cancel', kwargs={'pk': purchase.id})\n        response = self.client.post(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        \n        # Check if purchase was cancelled\n        purchase.refresh_from_db()\n        self.assertEqual(purchase.status, 'cancelled')\n","size_bytes":12976},"apps/tickets/urls.py":{"content":"from django.urls import path, include\nfrom rest_framework.routers import DefaultRouter\nfrom rest_framework_nested import routers\n\nfrom .views import TicketViewSet, PurchaseViewSet, TicketValidationViewSet, AttendeeViewSet\n\n# Create router for tickets and purchases\nrouter = DefaultRouter()\nrouter.register(r'purchases', PurchaseViewSet, basename='purchase')\nrouter.register(r'validations', TicketValidationViewSet, basename='ticket-validation')\nrouter.register(r'attendees', AttendeeViewSet, basename='attendee')\n\n# Create nested router for event tickets\nfrom apps.events.views import EventViewSet\nevents_router = routers.NestedDefaultRouter(\n    parent_router=DefaultRouter(),\n    parent_prefix=r'events',\n    lookup='event'\n)\nevents_router.register(r'tickets', TicketViewSet, basename='event-tickets')\n\nurlpatterns = [\n    path('', include(router.urls)),\n    # Event-specific tickets are handled in events app\n]\n","size_bytes":914},"apps/tickets/views.py":{"content":"from rest_framework import generics, status, permissions, viewsets\nfrom rest_framework.decorators import action\nfrom rest_framework.response import Response\nfrom django.shortcuts import get_object_or_404\nfrom django.db import transaction\nfrom django.utils import timezone\nfrom drf_spectacular.utils import extend_schema, OpenApiParameter, OpenApiResponse\nimport json\n\nfrom .models import Ticket, Purchase, Attendee, TicketValidation\nfrom .serializers import (\n    TicketSerializer,\n    TicketCreateUpdateSerializer,\n    PurchaseSerializer,\n    TicketPurchaseSerializer,\n    AttendeeSerializer,\n    QRCodeValidationSerializer,\n    TicketValidationSerializer,\n    PurchaseCreateSerializer\n)\nfrom apps.events.models import Event\nfrom apps.payments.services import PaymentService\n\nclass TicketPermission(permissions.BasePermission):\n    \"\"\"\n    Custom permission for tickets:\n    - Anyone can read tickets\n    - Only event organizers can create/update/delete tickets for their events\n    - Admins can do everything\n    \"\"\"\n    \n    def has_permission(self, request, view):\n        if request.method in permissions.SAFE_METHODS:\n            return True\n        \n        if not request.user.is_authenticated:\n            return False\n        \n        return request.user.role in ['organizer', 'admin']\n    \n    def has_object_permission(self, request, view, obj):\n        if request.method in permissions.SAFE_METHODS:\n            return True\n        \n        if request.user.role == 'admin':\n            return True\n        \n        # Check if user is the event organizer\n        if hasattr(obj, 'event'):\n            return obj.event.organizer == request.user\n        elif hasattr(obj, 'ticket'):\n            return obj.ticket.event.organizer == request.user\n        \n        return False\n\nclass TicketViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    ViewSet for managing tickets\n    \"\"\"\n    serializer_class = TicketSerializer\n    permission_classes = [TicketPermission]\n    \n    def get_queryset(self):\n        if hasattr(self, 'event_id'):\n            return Ticket.objects.filter(\n                event_id=self.event_id, \n                is_active=True\n            ).select_related('event')\n        return Ticket.objects.filter(is_active=True).select_related('event')\n    \n    def get_serializer_class(self):\n        if self.action in ['create', 'update', 'partial_update']:\n            return TicketCreateUpdateSerializer\n        return TicketSerializer\n    \n    def perform_create(self, serializer):\n        event = get_object_or_404(Event, id=self.kwargs.get('event_pk'))\n        \n        # Check permission\n        if self.request.user.role != 'admin' and event.organizer != self.request.user:\n            from rest_framework.exceptions import PermissionDenied\n            raise PermissionDenied(\"You can only create tickets for your own events\")\n        \n        serializer.save(event=event)\n    \n    @extend_schema(\n        summary=\"Create Ticket Type\",\n        description=\"Create a new ticket type for an event (organizers and admins only)\",\n        request=TicketCreateUpdateSerializer,\n        responses={201: TicketSerializer}\n    )\n    def create(self, request, *args, **kwargs):\n        return super().create(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"List Tickets\",\n        description=\"Get list of available tickets for an event\",\n        responses={200: TicketSerializer(many=True)}\n    )\n    def list(self, request, *args, **kwargs):\n        return super().list(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Purchase Ticket\",\n        description=\"Purchase a ticket\",\n        request=TicketPurchaseSerializer,\n        responses={201: PurchaseSerializer}\n    )\n    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAuthenticated])\n    def purchase(self, request, pk=None):\n        \"\"\"Purchase a ticket\"\"\"\n        ticket = self.get_object()\n        serializer = TicketPurchaseSerializer(data=request.data)\n        \n        if serializer.is_valid():\n            quantity = serializer.validated_data['quantity']\n            payment_method = serializer.validated_data['payment_method']\n            attendees_data = serializer.validated_data.get('attendees', [])\n            \n            # Check if ticket can be purchased\n            if not ticket.can_purchase(quantity):\n                return Response({\n                    'error': 'Ticket not available for purchase or insufficient quantity'\n                }, status=status.HTTP_400_BAD_REQUEST)\n            \n            # Check if event hasn't started\n            if ticket.event.is_past:\n                return Response({\n                    'error': 'Cannot purchase tickets for past events'\n                }, status=status.HTTP_400_BAD_REQUEST)\n            \n            try:\n                with transaction.atomic():\n                    # Create purchase\n                    purchase_data = {\n                        'ticket': ticket,\n                        'user': request.user,\n                        'quantity': quantity,\n                        'unit_price': ticket.price,\n                        'payment_method': payment_method\n                    }\n                    \n                    purchase_serializer = PurchaseCreateSerializer(data=purchase_data)\n                    purchase_serializer.is_valid(raise_exception=True)\n                    purchase = purchase_serializer.save()\n                    \n                    # Process payment\n                    payment_service = PaymentService()\n                    payment_data = {\n                        'amount': purchase.total_amount,\n                        'method': payment_method,\n                        'purchase_reference': purchase.purchase_reference\n                    }\n                    \n                    # Add payment method specific data\n                    if payment_method == 'mobile_money':\n                        payment_data['phone'] = serializer.validated_data['phone']\n                    elif payment_method == 'card':\n                        payment_data.update({\n                            'card_number': serializer.validated_data['card_number'],\n                            'card_expiry': serializer.validated_data['card_expiry'],\n                            'card_cvv': serializer.validated_data['card_cvv'],\n                            'card_holder_name': serializer.validated_data['card_holder_name']\n                        })\n                    \n                    payment_result = payment_service.process_payment(payment_data)\n                    \n                    if payment_result['success']:\n                        # Update purchase status\n                        purchase.status = 'paid'\n                        purchase.payment_reference = payment_result['reference']\n                        purchase.save()\n                        \n                        # Create attendees if provided\n                        if attendees_data:\n                            for attendee_data in attendees_data:\n                                Attendee.objects.create(\n                                    purchase=purchase,\n                                    **attendee_data\n                                )\n                        else:\n                            # Create default attendee with user info\n                            Attendee.objects.create(\n                                purchase=purchase,\n                                first_name=request.user.first_name,\n                                last_name=request.user.last_name,\n                                email=request.user.email,\n                                phone=request.user.phone or ''\n                            )\n                        \n                        # Send purchase confirmation notification\n                        from apps.notifications.services import NotificationService\n                        notification_service = NotificationService()\n                        notification_service.send_purchase_confirmation(purchase)\n                        \n                        return Response(\n                            PurchaseSerializer(purchase, context={'request': request}).data,\n                            status=status.HTTP_201_CREATED\n                        )\n                    else:\n                        # Payment failed\n                        purchase.status = 'cancelled'\n                        purchase.save()\n                        \n                        return Response({\n                            'error': 'Payment failed',\n                            'details': payment_result.get('error', 'Unknown error')\n                        }, status=status.HTTP_400_BAD_REQUEST)\n            \n            except Exception as e:\n                return Response({\n                    'error': 'Purchase failed',\n                    'details': str(e)\n                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\nclass PurchaseViewSet(viewsets.ReadOnlyModelViewSet):\n    \"\"\"\n    ViewSet for viewing purchases\n    \"\"\"\n    serializer_class = PurchaseSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_queryset(self):\n        user = self.request.user\n        \n        if user.role == 'admin':\n            return Purchase.objects.all().select_related('ticket__event', 'user').prefetch_related('attendees')\n        else:\n            return Purchase.objects.filter(user=user).select_related('ticket__event').prefetch_related('attendees')\n    \n    @extend_schema(\n        summary=\"Get Purchase Details\",\n        description=\"Get detailed information about a purchase including QR code\",\n        responses={200: PurchaseSerializer}\n    )\n    def retrieve(self, request, *args, **kwargs):\n        return super().retrieve(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Cancel Purchase\",\n        description=\"Cancel a purchase if allowed\",\n        responses={200: PurchaseSerializer}\n    )\n    @action(detail=True, methods=['post'])\n    def cancel(self, request, pk=None):\n        \"\"\"Cancel a purchase\"\"\"\n        purchase = self.get_object()\n        \n        if not purchase.can_be_cancelled:\n            return Response({\n                'error': 'Purchase cannot be cancelled'\n            }, status=status.HTTP_400_BAD_REQUEST)\n        \n        try:\n            purchase.cancel()\n            \n            # Send cancellation notification\n            from apps.notifications.services import NotificationService\n            notification_service = NotificationService()\n            notification_service.send_purchase_cancellation(purchase)\n            \n            return Response(\n                PurchaseSerializer(purchase, context={'request': request}).data\n            )\n        \n        except ValueError as e:\n            return Response({\n                'error': str(e)\n            }, status=status.HTTP_400_BAD_REQUEST)\n    \n    @extend_schema(\n        summary=\"Download Ticket\",\n        description=\"Download ticket as PDF\",\n        responses={200: \"PDF file\"}\n    )\n    @action(detail=True, methods=['get'])\n    def download(self, request, pk=None):\n        \"\"\"Download ticket as PDF\"\"\"\n        purchase = self.get_object()\n        \n        if purchase.status != 'paid':\n            return Response({\n                'error': 'Ticket not available for download'\n            }, status=status.HTTP_400_BAD_REQUEST)\n        \n        # Here you would generate a PDF ticket\n        # For now, return the purchase data\n        return Response({\n            'message': 'PDF generation would be implemented here',\n            'purchase': PurchaseSerializer(purchase, context={'request': request}).data\n        })\n\nclass TicketValidationViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    ViewSet for ticket validation at events\n    \"\"\"\n    serializer_class = TicketValidationSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_queryset(self):\n        return TicketValidation.objects.all().select_related('purchase__ticket__event', 'validated_by')\n    \n    @extend_schema(\n        summary=\"Validate QR Code\",\n        description=\"Validate a ticket QR code for event entry\",\n        request=QRCodeValidationSerializer,\n        responses={200: TicketValidationSerializer}\n    )\n    @action(detail=False, methods=['post'])\n    def validate_qr(self, request):\n        \"\"\"Validate a QR code for event entry\"\"\"\n        serializer = QRCodeValidationSerializer(data=request.data)\n        \n        if serializer.is_valid():\n            qr_code_data = serializer.validated_data['qr_code_data']\n            location = serializer.validated_data.get('location', '')\n            notes = serializer.validated_data.get('notes', '')\n            \n            try:\n                # Parse QR code data\n                qr_data = json.loads(qr_code_data)\n                purchase_id = qr_data.get('purchase_id')\n                \n                if not purchase_id:\n                    return Response({\n                        'error': 'Invalid QR code format'\n                    }, status=status.HTTP_400_BAD_REQUEST)\n                \n                # Get purchase\n                purchase = get_object_or_404(Purchase, id=purchase_id)\n                \n                # Validate purchase\n                if purchase.status != 'paid':\n                    return Response({\n                        'error': 'Ticket is not valid for entry',\n                        'status': purchase.status\n                    }, status=status.HTTP_400_BAD_REQUEST)\n                \n                # Check if event is today or ongoing\n                event = purchase.ticket.event\n                now = timezone.now()\n                \n                if event.end_datetime < now:\n                    return Response({\n                        'error': 'Event has ended'\n                    }, status=status.HTTP_400_BAD_REQUEST)\n                \n                if event.start_datetime.date() > now.date():\n                    return Response({\n                        'error': 'Event has not started yet'\n                    }, status=status.HTTP_400_BAD_REQUEST)\n                \n                # Check if already validated recently (prevent double entry)\n                recent_validation = TicketValidation.objects.filter(\n                    purchase=purchase,\n                    validation_datetime__gte=now - timezone.timedelta(hours=1)\n                ).first()\n                \n                if recent_validation:\n                    return Response({\n                        'warning': 'Ticket was already validated recently',\n                        'validation': TicketValidationSerializer(recent_validation).data,\n                        'purchase': PurchaseSerializer(purchase, context={'request': request}).data\n                    })\n                \n                # Create validation record\n                validation = TicketValidation.objects.create(\n                    purchase=purchase,\n                    validated_by=request.user,\n                    location=location,\n                    notes=notes\n                )\n                \n                return Response({\n                    'success': True,\n                    'message': 'Ticket validated successfully',\n                    'validation': TicketValidationSerializer(validation).data,\n                    'purchase': PurchaseSerializer(purchase, context={'request': request}).data\n                })\n            \n            except json.JSONDecodeError:\n                return Response({\n                    'error': 'Invalid QR code format'\n                }, status=status.HTTP_400_BAD_REQUEST)\n            \n            except Exception as e:\n                return Response({\n                    'error': 'Validation failed',\n                    'details': str(e)\n                }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\nclass AttendeeViewSet(viewsets.ModelViewSet):\n    \"\"\"\n    ViewSet for managing attendees\n    \"\"\"\n    serializer_class = AttendeeSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_queryset(self):\n        user = self.request.user\n        \n        if user.role == 'admin':\n            return Attendee.objects.all().select_related('purchase__ticket__event')\n        else:\n            # Users can only see attendees from their own purchases\n            return Attendee.objects.filter(purchase__user=user).select_related('purchase__ticket__event')\n    \n    @extend_schema(\n        summary=\"Check In Attendee\",\n        description=\"Check in an attendee to the event\",\n        responses={200: AttendeeSerializer}\n    )\n    @action(detail=True, methods=['post'])\n    def check_in(self, request, pk=None):\n        \"\"\"Check in an attendee\"\"\"\n        attendee = self.get_object()\n        \n        if attendee.checked_in:\n            return Response({\n                'message': 'Attendee is already checked in',\n                'attendee': AttendeeSerializer(attendee).data\n            })\n        \n        attendee.check_in()\n        \n        return Response({\n            'message': 'Attendee checked in successfully',\n            'attendee': AttendeeSerializer(attendee).data\n        })\n","size_bytes":17404},"apps/users/__init__.py":{"content":"","size_bytes":0},"apps/users/models.py":{"content":"from django.contrib.auth.models import AbstractUser\nfrom django.db import models\n\nclass User(AbstractUser):\n    \"\"\"\n    Custom User model extending Django's AbstractUser\n    \"\"\"\n    ROLE_CHOICES = [\n        ('participant', 'Participant'),\n        ('organizer', 'Organizer'),\n        ('admin', 'Admin'),\n    ]\n    \n    email = models.EmailField(unique=True)\n    first_name = models.CharField(max_length=30)\n    last_name = models.CharField(max_length=30)\n    phone = models.CharField(max_length=20, blank=True, null=True)\n    role = models.CharField(max_length=20, choices=ROLE_CHOICES, default='participant')\n    is_active = models.BooleanField(default=True)\n    date_joined = models.DateTimeField(auto_now_add=True)\n    updated_at = models.DateTimeField(auto_now=True)\n    \n    # Use email as username field\n    USERNAME_FIELD = 'email'\n    REQUIRED_FIELDS = ['first_name', 'last_name']\n    \n    class Meta:\n        db_table = 'users'\n        verbose_name = 'User'\n        verbose_name_plural = 'Users'\n    \n    def __str__(self):\n        return f\"{self.first_name} {self.last_name} ({self.email})\"\n    \n    @property\n    def full_name(self):\n        return f\"{self.first_name} {self.last_name}\"\n    \n    def is_organizer(self):\n        return self.role == 'organizer'\n    \n    def is_admin_user(self):\n        return self.role == 'admin'\n    \n    def is_participant(self):\n        return self.role == 'participant'\n","size_bytes":1417},"apps/users/serializers.py":{"content":"from rest_framework import serializers\nfrom django.contrib.auth import authenticate\nfrom django.contrib.auth.password_validation import validate_password\nfrom .models import User\n\nclass UserSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for User model\n    \"\"\"\n    class Meta:\n        model = User\n        fields = ['id', 'email', 'first_name', 'last_name', 'phone', 'role', 'is_active', 'date_joined']\n        read_only_fields = ['id', 'date_joined']\n\nclass UserRegistrationSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for user registration\n    \"\"\"\n    password = serializers.CharField(write_only=True, validators=[validate_password])\n    password_confirm = serializers.CharField(write_only=True)\n    \n    class Meta:\n        model = User\n        fields = ['email', 'password', 'password_confirm', 'first_name', 'last_name', 'phone', 'role']\n        \n    def validate(self, attrs):\n        if attrs['password'] != attrs['password_confirm']:\n            raise serializers.ValidationError(\"Passwords don't match\")\n        return attrs\n    \n    def validate_role(self, value):\n        # Only allow participant and organizer roles during registration\n        if value not in ['participant', 'organizer']:\n            raise serializers.ValidationError(\"Invalid role. Choose 'participant' or 'organizer'.\")\n        return value\n    \n    def create(self, validated_data):\n        validated_data.pop('password_confirm')\n        password = validated_data.pop('password')\n        \n        user = User(**validated_data)\n        user.set_password(password)\n        user.save()\n        \n        return user\n\nclass UserLoginSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for user login\n    \"\"\"\n    email = serializers.EmailField()\n    password = serializers.CharField(write_only=True)\n    \n    def validate(self, attrs):\n        email = attrs.get('email')\n        password = attrs.get('password')\n        \n        if email and password:\n            user = authenticate(username=email, password=password)\n            \n            if not user:\n                raise serializers.ValidationError('Invalid email or password.')\n            \n            if not user.is_active:\n                raise serializers.ValidationError('User account is disabled.')\n            \n            attrs['user'] = user\n            return attrs\n        \n        raise serializers.ValidationError('Must provide email and password.')\n\nclass UserUpdateSerializer(serializers.ModelSerializer):\n    \"\"\"\n    Serializer for updating user profile\n    \"\"\"\n    class Meta:\n        model = User\n        fields = ['first_name', 'last_name', 'phone']\n        \n    def update(self, instance, validated_data):\n        for attr, value in validated_data.items():\n            setattr(instance, attr, value)\n        instance.save()\n        return instance\n\nclass PasswordChangeSerializer(serializers.Serializer):\n    \"\"\"\n    Serializer for changing password\n    \"\"\"\n    old_password = serializers.CharField(write_only=True)\n    new_password = serializers.CharField(write_only=True, validators=[validate_password])\n    new_password_confirm = serializers.CharField(write_only=True)\n    \n    def validate(self, attrs):\n        if attrs['new_password'] != attrs['new_password_confirm']:\n            raise serializers.ValidationError(\"New passwords don't match\")\n        return attrs\n    \n    def validate_old_password(self, value):\n        user = self.context['request'].user\n        if not user.check_password(value):\n            raise serializers.ValidationError(\"Old password is incorrect\")\n        return value\n    \n    def save(self):\n        user = self.context['request'].user\n        user.set_password(self.validated_data['new_password'])\n        user.save()\n        return user\n","size_bytes":3773},"apps/users/tests.py":{"content":"from django.test import TestCase\nfrom django.urls import reverse\nfrom rest_framework.test import APITestCase\nfrom rest_framework import status\nfrom django.contrib.auth import get_user_model\n\nUser = get_user_model()\n\nclass UserModelTest(TestCase):\n    \"\"\"\n    Test cases for User model\n    \"\"\"\n    \n    def setUp(self):\n        self.user_data = {\n            'email': 'test@example.com',\n            'first_name': 'John',\n            'last_name': 'Doe',\n            'phone': '+22912345678',\n            'role': 'participant'\n        }\n    \n    def test_create_user(self):\n        \"\"\"Test creating a user\"\"\"\n        user = User.objects.create_user(\n            email=self.user_data['email'],\n            password='testpass123',\n            **{k: v for k, v in self.user_data.items() if k != 'email'}\n        )\n        \n        self.assertEqual(user.email, self.user_data['email'])\n        self.assertEqual(user.first_name, self.user_data['first_name'])\n        self.assertEqual(user.role, 'participant')\n        self.assertTrue(user.is_active)\n        self.assertFalse(user.is_staff)\n    \n    def test_user_string_representation(self):\n        \"\"\"Test user string representation\"\"\"\n        user = User.objects.create_user(\n            email=self.user_data['email'],\n            password='testpass123',\n            **{k: v for k, v in self.user_data.items() if k != 'email'}\n        )\n        \n        expected_str = f\"{user.first_name} {user.last_name} ({user.email})\"\n        self.assertEqual(str(user), expected_str)\n    \n    def test_user_role_methods(self):\n        \"\"\"Test user role checking methods\"\"\"\n        participant = User.objects.create_user(\n            email='participant@example.com',\n            password='testpass123',\n            first_name='John',\n            last_name='Participant',\n            role='participant'\n        )\n        \n        organizer = User.objects.create_user(\n            email='organizer@example.com',\n            password='testpass123',\n            first_name='Jane',\n            last_name='Organizer',\n            role='organizer'\n        )\n        \n        admin = User.objects.create_user(\n            email='admin@example.com',\n            password='testpass123',\n            first_name='Admin',\n            last_name='User',\n            role='admin'\n        )\n        \n        self.assertTrue(participant.is_participant())\n        self.assertFalse(participant.is_organizer())\n        self.assertFalse(participant.is_admin_user())\n        \n        self.assertTrue(organizer.is_organizer())\n        self.assertFalse(organizer.is_participant())\n        self.assertFalse(organizer.is_admin_user())\n        \n        self.assertTrue(admin.is_admin_user())\n        self.assertFalse(admin.is_participant())\n        self.assertFalse(admin.is_organizer())\n\nclass UserAPITest(APITestCase):\n    \"\"\"\n    Test cases for User API endpoints\n    \"\"\"\n    \n    def setUp(self):\n        self.registration_data = {\n            'email': 'test@example.com',\n            'password': 'testpass123',\n            'password_confirm': 'testpass123',\n            'first_name': 'John',\n            'last_name': 'Doe',\n            'phone': '+22912345678',\n            'role': 'participant'\n        }\n        \n        self.login_data = {\n            'email': 'test@example.com',\n            'password': 'testpass123'\n        }\n    \n    def test_user_registration(self):\n        \"\"\"Test user registration\"\"\"\n        url = reverse('user-register')\n        response = self.client.post(url, self.registration_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_201_CREATED)\n        self.assertIn('access', response.data)\n        self.assertIn('refresh', response.data)\n        self.assertIn('user', response.data)\n        \n        # Check if user was created\n        user = User.objects.get(email=self.registration_data['email'])\n        self.assertEqual(user.first_name, self.registration_data['first_name'])\n    \n    def test_user_registration_password_mismatch(self):\n        \"\"\"Test registration with password mismatch\"\"\"\n        url = reverse('user-register')\n        data = self.registration_data.copy()\n        data['password_confirm'] = 'differentpassword'\n        \n        response = self.client.post(url, data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)\n    \n    def test_user_login(self):\n        \"\"\"Test user login\"\"\"\n        # First register a user\n        User.objects.create_user(\n            email=self.login_data['email'],\n            password=self.login_data['password'],\n            first_name='John',\n            last_name='Doe'\n        )\n        \n        url = reverse('user-login')\n        response = self.client.post(url, self.login_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertIn('access', response.data)\n        self.assertIn('refresh', response.data)\n        self.assertIn('user', response.data)\n    \n    def test_user_login_invalid_credentials(self):\n        \"\"\"Test login with invalid credentials\"\"\"\n        url = reverse('user-login')\n        response = self.client.post(url, self.login_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)\n    \n    def test_get_user_profile(self):\n        \"\"\"Test getting user profile\"\"\"\n        user = User.objects.create_user(\n            email='test@example.com',\n            password='testpass123',\n            first_name='John',\n            last_name='Doe'\n        )\n        \n        self.client.force_authenticate(user=user)\n        url = reverse('user-profile')\n        response = self.client.get(url)\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(response.data['email'], user.email)\n        self.assertEqual(response.data['first_name'], user.first_name)\n    \n    def test_update_user_profile(self):\n        \"\"\"Test updating user profile\"\"\"\n        user = User.objects.create_user(\n            email='test@example.com',\n            password='testpass123',\n            first_name='John',\n            last_name='Doe'\n        )\n        \n        self.client.force_authenticate(user=user)\n        url = reverse('user-profile')\n        \n        update_data = {\n            'first_name': 'Jane',\n            'phone': '+22987654321'\n        }\n        \n        response = self.client.patch(url, update_data, format='json')\n        \n        self.assertEqual(response.status_code, status.HTTP_200_OK)\n        self.assertEqual(response.data['first_name'], 'Jane')\n        self.assertEqual(response.data['phone'], '+22987654321')\n        \n        # Verify user was updated in database\n        user.refresh_from_db()\n        self.assertEqual(user.first_name, 'Jane')\n        self.assertEqual(user.phone, '+22987654321')\n","size_bytes":6859},"apps/users/urls.py":{"content":"from django.urls import path\nfrom .views import (\n    UserRegistrationView,\n    UserLoginView,\n    UserLogoutView,\n    UserProfileView,\n    PasswordChangeView,\n    CustomTokenRefreshView\n)\n\nurlpatterns = [\n    # Authentication endpoints\n    path('register/', UserRegistrationView.as_view(), name='user-register'),\n    path('login/', UserLoginView.as_view(), name='user-login'),\n    path('logout/', UserLogoutView.as_view(), name='user-logout'),\n    path('refresh/', CustomTokenRefreshView.as_view(), name='token-refresh'),\n    \n    # User profile endpoints\n    path('me/', UserProfileView.as_view(), name='user-profile'),\n    path('change-password/', PasswordChangeView.as_view(), name='change-password'),\n]\n","size_bytes":708},"apps/users/views.py":{"content":"from rest_framework import status, generics, permissions\nfrom rest_framework.decorators import api_view, permission_classes\nfrom rest_framework.response import Response\nfrom rest_framework.views import APIView\nfrom rest_framework_simplejwt.tokens import RefreshToken\nfrom rest_framework_simplejwt.views import TokenRefreshView\nfrom django.contrib.auth import logout\nfrom drf_spectacular.utils import extend_schema, OpenApiResponse\n\nfrom .models import User\nfrom .serializers import (\n    UserSerializer, \n    UserRegistrationSerializer, \n    UserLoginSerializer,\n    UserUpdateSerializer,\n    PasswordChangeSerializer\n)\n\nclass UserRegistrationView(generics.CreateAPIView):\n    \"\"\"\n    User registration endpoint\n    \"\"\"\n    queryset = User.objects.all()\n    serializer_class = UserRegistrationSerializer\n    permission_classes = [permissions.AllowAny]\n    \n    @extend_schema(\n        summary=\"User Registration\",\n        description=\"Register a new user account\",\n        responses={\n            201: OpenApiResponse(description=\"User created successfully\"),\n            400: OpenApiResponse(description=\"Invalid data provided\"),\n        }\n    )\n    def post(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        \n        if serializer.is_valid():\n            user = serializer.save()\n            \n            # Generate JWT tokens\n            refresh = RefreshToken.for_user(user)\n            \n            return Response({\n                'user': UserSerializer(user).data,\n                'refresh': str(refresh),\n                'access': str(refresh.access_token),\n                'message': 'User registered successfully'\n            }, status=status.HTTP_201_CREATED)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\nclass UserLoginView(APIView):\n    \"\"\"\n    User login endpoint\n    \"\"\"\n    permission_classes = [permissions.AllowAny]\n    \n    @extend_schema(\n        summary=\"User Login\",\n        description=\"Authenticate user and return JWT tokens\",\n        request=UserLoginSerializer,\n        responses={\n            200: OpenApiResponse(description=\"Login successful\"),\n            401: OpenApiResponse(description=\"Invalid credentials\"),\n        }\n    )\n    def post(self, request):\n        serializer = UserLoginSerializer(data=request.data)\n        \n        if serializer.is_valid():\n            user = serializer.validated_data['user']\n            \n            # Generate JWT tokens\n            refresh = RefreshToken.for_user(user)\n            \n            return Response({\n                'user': UserSerializer(user).data,\n                'refresh': str(refresh),\n                'access': str(refresh.access_token),\n                'message': 'Login successful'\n            }, status=status.HTTP_200_OK)\n        \n        return Response(serializer.errors, status=status.HTTP_401_UNAUTHORIZED)\n\nclass UserLogoutView(APIView):\n    \"\"\"\n    User logout endpoint\n    \"\"\"\n    permission_classes = [permissions.IsAuthenticated]\n    \n    @extend_schema(\n        summary=\"User Logout\",\n        description=\"Logout user and blacklist refresh token\",\n        responses={\n            200: OpenApiResponse(description=\"Logout successful\"),\n        }\n    )\n    def post(self, request):\n        try:\n            refresh_token = request.data.get('refresh')\n            if refresh_token:\n                token = RefreshToken(refresh_token)\n                token.blacklist()\n            \n            logout(request)\n            return Response({\n                'message': 'Logout successful'\n            }, status=status.HTTP_200_OK)\n        \n        except Exception as e:\n            return Response({\n                'error': 'Invalid token'\n            }, status=status.HTTP_400_BAD_REQUEST)\n\nclass UserProfileView(generics.RetrieveUpdateAPIView):\n    \"\"\"\n    User profile view - get and update current user profile\n    \"\"\"\n    serializer_class = UserSerializer\n    permission_classes = [permissions.IsAuthenticated]\n    \n    def get_object(self):\n        return self.request.user\n    \n    def get_serializer_class(self):\n        if self.request.method == 'PATCH':\n            return UserUpdateSerializer\n        return UserSerializer\n    \n    @extend_schema(\n        summary=\"Get User Profile\",\n        description=\"Get current user profile information\",\n        responses={\n            200: UserSerializer,\n        }\n    )\n    def get(self, request, *args, **kwargs):\n        return super().get(request, *args, **kwargs)\n    \n    @extend_schema(\n        summary=\"Update User Profile\",\n        description=\"Update current user profile information\",\n        request=UserUpdateSerializer,\n        responses={\n            200: UserSerializer,\n        }\n    )\n    def patch(self, request, *args, **kwargs):\n        return super().patch(request, *args, **kwargs)\n\nclass PasswordChangeView(APIView):\n    \"\"\"\n    Change user password\n    \"\"\"\n    permission_classes = [permissions.IsAuthenticated]\n    \n    @extend_schema(\n        summary=\"Change Password\",\n        description=\"Change current user password\",\n        request=PasswordChangeSerializer,\n        responses={\n            200: OpenApiResponse(description=\"Password changed successfully\"),\n            400: OpenApiResponse(description=\"Invalid data provided\"),\n        }\n    )\n    def post(self, request):\n        serializer = PasswordChangeSerializer(\n            data=request.data, \n            context={'request': request}\n        )\n        \n        if serializer.is_valid():\n            serializer.save()\n            return Response({\n                'message': 'Password changed successfully'\n            }, status=status.HTTP_200_OK)\n        \n        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)\n\n# Custom Token Refresh View\nclass CustomTokenRefreshView(TokenRefreshView):\n    \"\"\"\n    Custom token refresh view with extended schema\n    \"\"\"\n    @extend_schema(\n        summary=\"Refresh Access Token\",\n        description=\"Get a new access token using refresh token\",\n        responses={\n            200: OpenApiResponse(description=\"Token refreshed successfully\"),\n            401: OpenApiResponse(description=\"Invalid refresh token\"),\n        }\n    )\n    def post(self, request, *args, **kwargs):\n        return super().post(request, *args, **kwargs)\n","size_bytes":6334}},"version":1}